<!DOCTYPE html>
<html lang="en">
<head>
    <title>GlueX HDvis -- Dmitry Romanov and Thomas Britton</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            margin: 0px;
            overflow: hidden;
            background: #f0f0f0 url("background_dark1.jpg");
        }

        .button {
            display: inline-block;
            position: relative;
            margin: 10px;
            padding: 0 20px;
            text-align: center;
            text-decoration: none;
            font: bold 12px/25px Arial, sans-serif;

            text-shadow: 1px 1px 1px rgba(255,255,255, .22);

            -webkit-border-radius: 30px;
            -moz-border-radius: 30px;
            border-radius: 30px;

            -webkit-box-shadow: 1px 1px 1px rgba(0,0,0, .29), inset 1px 1px 1px rgba(255,255,255, .44);
            -moz-box-shadow: 1px 1px 1px rgba(0,0,0, .29), inset 1px 1px 1px rgba(255,255,255, .44);
            box-shadow: 1px 1px 1px rgba(0,0,0, .29), inset 1px 1px 1px rgba(255,255,255, .44);

            -webkit-transition: all 0.15s ease;
            -moz-transition: all 0.15s ease;
            -o-transition: all 0.15s ease;
            -ms-transition: all 0.15s ease;
            transition: all 0.15s ease;
        }

        /* Green Color */

        .green {
            color: #3e5706;

            background: #a5cd4e; /* Old browsers */
            background: -moz-linear-gradient(top,  #a5cd4e 0%, #6b8f1a 100%); /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#a5cd4e), color-stop(100%,#6b8f1a)); /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* Opera 11.10+ */
            background: -ms-linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* IE10+ */
            background: linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* W3C */
        }

        /* Blue Color */

        .blue {
            color: #19667d;

            background: #70c9e3; /* Old browsers */
            background: -moz-linear-gradient(top,  #70c9e3 0%, #39a0be 100%); /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#70c9e3), color-stop(100%,#39a0be)); /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* Opera 11.10+ */
            background: -ms-linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* IE10+ */
            background: linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* W3C */
        }

        /* Gray Color */

        .gray {
            color: #515151;

            background: #d3d3d3; /* Old browsers */
            background: -moz-linear-gradient(top,  #d3d3d3 0%, #8a8a8a 100%); /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#d3d3d3), color-stop(100%,#8a8a8a)); /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* Opera 11.10+ */
            background: -ms-linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* IE10+ */
            background: linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* W3C */
        }

        .button:hover {
            -webkit-box-shadow: 1px 1px 1px rgba(0,0,0,.29), inset 0px 0px 2px rgba(0,0,0, .5);
            -moz-box-shadow: 1px 1px 1px rgba(0,0,0,.29), inset 0px 0px 2px rgba(0,0,0, .5);
            box-shadow: 1px 1px 1px rgba(0,0,0,.29), inset 0px 0px 2px rgba(0,0,0, .5);
        }

        .button:active {
            -webkit-box-shadow: inset 0px 0px 3px rgba(0,0,0, .8);
            -moz-box-shadow: inset 0px 0px 3px rgba(0,0,0, .8);
            box-shadow: inset 0px 0px 3px rgba(0,0,0, .8);
        }

        #canvas {
            background-color: #000;
            width: 200px;
            height: 200px;
            border: 1px solid black;
            margin: 100px;
            padding: 0px;
            position: static; /* fixed or static */
            top: 100px;
            left: 100px;
        }


    </style>
    <link rel="stylesheet" type="text/css" href="dat.gui.css" />

</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/FlyControls.js"></script>
<script src="js/libs/stats.min.js"></script>
<script src="js/libs/dat.gui.min.js"></script>
<script src="js/GluexEventLoader.js"></script>
<script src="js/GluexHDDSLoader.js"></script>
<script src="js/GluexGUI.js"></script>
<script src="js/effects/StereoEffect.js"></script>
<script src="js/vr/WebVR.js"></script>
<script src="js/threex.geometricglowmesh.js"></script>
<script src="js/threex.dilategeometry.js"></script>
<script src="js/threex.atmospherematerial.js"></script>
<script src="js/cameras/CombinedCamera.js"></script>
<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>


<nav style="position:absolute; left: 100px; z-index: 100">
    <!--<a href="#" class="button green">button</a>-->

    <!--<a href="#" class="button blue">button</a>-->

    <a href="#" class="button gray" OnClick="next_click()">next</a>
    <a id="autoPlay" href="#" class="button gray" OnClick="autoplay_click()">autoplay</a>
    <span id="janaStatus" style="color: darkgray"> JANA status </span>
    <span style="display: block; text-align: center;color: green; font-size: 30px" id="EventClock" > Event Clock </span>
</nav>
<script>
    function next_click() {
        console.log("calling /api/v1/next");
        firstShowing=true;
        clock.stop();
        var xhr = new XMLHttpRequest();
        previousJanaState = "Processing";
        xhr.open('GET', "/api/v1/next", true);
        xhr.send();


    }

    function autoplay_click() {
        console.log("calling /api/v1/autoplay-on");
        var xhr = new XMLHttpRequest();
        xhr.open('GET', "/api/v1/autoplay-on", true);
        xhr.send();
    }
</script>

<script>
    var previousJanaState = "";


    (function poll() {
        //alert("hey");
        $.ajax({
            url: "/api/v1/status",
            type: "GET",
            success: function(data) {

                var message = "JANA: " + data.janaState + " event: " + data.eventNumber.toString();

                if(data.janaState === "Idle" && previousJanaState!== "Idle") {
                    loadEventFromFile();
                }

                previousJanaState = data.janaState;

                console.log("polling result => " + message);
                if(data.isAutoPlay) {
                    if($("#autoPlay").hasClass("gray")){
                        $("#autoPlay").removeClass("gray").addClass("green");
                    }
                }
                $("#janaStatus").text(message);
            },
            dataType: "json",
            complete: setTimeout(function() {poll()}, 1000),
            timeout: 2000
        })
    })();

    var clock = new THREE.Clock();
    var container, stats;

    var camera,ortho_camera, controls, scene, renderer, raycaster;

    var camera_facing = new THREE.Vector3( 0, 0, -1 );
    var orbit_point=new THREE.Vector3();

    var canvas1, context1, texture1;
    var sprite1;
    var firstShowing=true;
    var VRbool=false;

    var ViewerConfig;
    // start scene
    var mouse = new THREE.Vector2(), INTERSECTED;

    var gluexGeometry = null;

    var max_swim_steps=0;
    var max_swim_time=0;
    var min_start_time=99999999999;
    var max_total_time=-9999999999;

    var SCgeo=null;

    // var animationTimings=[min_start_time,max_swim_steps,max_swim_time,max_total_time];

    keyState: new Array();


    if(VRbool)
    {
        WEBVR.checkAvailability().catch( function( message ) {
            document.body.appendChild( WEBVR.getMessageContainer( message ) );
        } );

    }

    init();
    animate();

    function recursiveRemove(mesh) {
        while(mesh.children.length > 0){
            var child = mesh.children[0];
            recursiveRemove(child);
            mesh.remove(child);
        }
    }

    function loadEventFromFile() {
        if(!gluexGeometry){
            console.info("Can't load event because geometry is still not loaded");
            return;
        }

        // hard cleanup!
        var existingGeometry = scene.getObjectByName('GluexGeometry');
        var event = scene.getObjectByName('GluexEvent');
        if(!existingGeometry) {
            scene.add(gluexGeometry);
        }
        if(event) {
            recursiveRemove(event);
            scene.remove(event);
        }


        var eventLoader = new THREE.GluexEventLoader();
        eventLoader.setConfiguration(ViewerConfig);
        eventLoader.setGeometry(gluexGeometry);
        eventLoader.load('./event.json', function(loadedEvent) {
            scene.add(loadedEvent);
            UpdateAnimationTriggers(loadedEvent.children);
        });
        firstShowing=true;

        clock.stop();
        clock.start();
    }

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        //camera = new THREE.CombinedCamera( window.innerWidth / 2, window.innerHeight / 2, 70, 1, 5000, 0, 5000 );
        //camera.toPerspective();
        // camera.toOrthographic();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
        camera.position.z = 371;//900;
        camera.position.x=-625;//-1000;
        camera.position.y=56;//100;




        scene = new THREE.Scene();

        var light = new THREE.PointLight( 0xffffff, 1.5 );
        light.position.set( 1000, 1000, 2000 );
        //scene.add( light );

        scene.add(new THREE.AmbientLight(0xFFFFFF/*A0A0A0*/));

        renderer = new THREE.WebGLRenderer( { antialias: false } ); // WebGLRenderer CanvasRenderer
        renderer.setClearColor( 0xff0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled=false;
        renderer.precision="lowp";
        container.appendChild( renderer.domElement );

        if(renderer.vr)
        {
            WEBVR.getVRDisplay( function ( display ) {
                renderer.vr.setDevice( display );
                document.body.appendChild( WEBVR.getButton( display, renderer.domElement ) );
            } );
        }

        stats = new Stats();
        document.body.appendChild(stats.dom);

        raycaster = new THREE.Raycaster();

        controls = new THREE.OrbitControls( camera, renderer.domElement );

        camera.updateMatrixWorld();
        resetOrbitPoint(controls,camera,camera_facing);

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'keydown', onKeyDown, false );

        var geometryLoader = new THREE.GluexHDDSLoader();

        geometryLoader.load('./hdds/main_full_HDDS.xml', function (loadedGeom) {
            gluexGeometry = loadedGeom;

            // when we have a geometry, we can load the event
            loadEventFromFile();
        });

        SCgeo=scene.getObjectByName("SC");

        object = new THREE.AxisHelper( 100 );
        object.position.set( 0, 0, 0 );
        //scene.add( object );

        renderer.setClearColor( 0x000000 );

        canvas1 = document.createElement('canvas');
        context1 = canvas1.getContext('2d');
        context1.font = "Bold 20px Arial";
        context1.fillStyle = "rgba(0,0,0,0.95)";
        context1.fillText('', 0, 20);

        texture1 = new THREE.Texture(canvas1);
        texture1.minFilter=THREE.LinearFilter;
        texture1.needsUpdate = true;

        var spriteMaterial = new THREE.SpriteMaterial( { map: texture1} );

        sprite1 = new THREE.Sprite( spriteMaterial );
        sprite1.scale.set(512,128,1.0);
        sprite1.position.set( mouse.x, mouse.y, 0 );
        scene.add( sprite1 );

        // GUI----------------------------------------------------------------------------------------
        ViewerConfig=makeGUI(scene);
    }

    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        raytracing();

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onKeyDown(event) {
        var MoveDelta=10;
        switch (event.keyCode) {

            case 86: VRbool = !VRbool;break;//v
            case 87: event.preventDefault();camera.translateZ(-MoveDelta);camera.updateMatrixWorld();
                resetOrbitPoint(controls,camera,camera_facing);raytracing();break;//w
            case 83: event.preventDefault();camera.translateZ(MoveDelta);camera.updateMatrixWorld();
                resetOrbitPoint(controls,camera,camera_facing);raytracing();break;//s
            case 65: event.preventDefault();camera.translateX(-MoveDelta);camera.updateMatrixWorld();
                resetOrbitPoint(controls,camera,camera_facing);raytracing();break;//a
            case 68: event.preventDefault();camera.translateX(MoveDelta);camera.updateMatrixWorld();
                resetOrbitPoint(controls,camera,camera_facing);raytracing();break;//d
            case 32: event.preventDefault();camera.translateY(MoveDelta);camera.updateMatrixWorld();
                resetOrbitPoint(controls,camera,camera_facing);raytracing();break;//spacebar
            case 90: event.preventDefault();camera.translateY(-MoveDelta);camera.updateMatrixWorld();
                resetOrbitPoint(controls,camera,camera_facing);raytracing();break;//z

        }

    }
    //
    function resetOrbitPoint(controls,camera,camera_facing)
    {
        camera.getWorldDirection( camera_facing );
        orbit_point=camera.position.clone().add(camera_facing.clone().setLength(30));//pretty much an arbitrary length above 10
        controls.target.set(orbit_point.x,orbit_point.y,orbit_point.z);
    }
    function updateTrackPositions(lineGeo,max_swim_steps) {
        var positions = lineGeo.children[0].geometry.attributes.position.array;
        var parent=lineGeo.geometry.vertices;
        var limit=parent.length;
        var index = 0;
        for ( var i = 0; i<max_swim_steps; i ++ ) {
            if(parent[i]) {
                positions[index++] = parent[i].x;
                positions[index++] = parent[i].y;
                positions[index++] = parent[i].z;
            }
            else
            {
                positions[index++] = parent[limit-1].x;
                positions[index++] = parent[limit-1].y;
                positions[index++] = parent[limit-1].z;
            }
        }
    }

    function animateFCALHits(clock,time_scale,eventobj,min_start_time,max_total_time) {
        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "FCALHit") {
            if (eventobj.userData.t > ViewerConfig.max_clock_time ||
                eventobj.userData.t < ViewerConfig.min_clock_time) {
                eventobj.material.visible = false;
                return;
            }//RESPECT THE CLOCK BOUNDS FCALHits
            else {
                if (eventobj.userData.E > ViewerConfig.FCAL_HitEcut && ViewerConfig.FCALHitVis !== "Off")
                    eventobj.material.visible = true;
            }

            if (ViewerConfig.FCALHitVis === "Dynamic") {
                if (SceneTime + min_start_time > eventobj.userData.t) {
                    eventobj.scale.set(1, 1, eventobj.userData.E * ViewerConfig.FCAL_EScale);
                    eventobj.position.z = (655 + (eventobj.userData.E * ViewerConfig.FCAL_EScale / 2) + 15);//(655+((SceneTime/max_total_time)*eventobjs[i].userData.E*ViewerConfig.FCAL_EScale)/2);
                    eventobj.geometryNeedsUpdate = true;

                }
                else if (SceneTime + min_start_time < eventobj.userData.t && eventobj.scale.z !== 1) {
                    eventobj.scale.set(1, 1, 1);
                    eventobj.position.z = (655 + 1 + 15);
                    eventobj.geometryNeedsUpdate = true;
                }
            }
            else if (ViewerConfig.FCALHitVis === "Off" && eventobj.material.visibile === true) {
                eventobj.material.visibile = false;
            }
            else if (ViewerConfig.FCALHitVis === "Static" && eventobj.scale.z !== eventobj.userData.E * ViewerConfig.FCAL_EScale) {
                eventobj.scale.set(1, 1, eventobjs[i].userData.E * ViewerConfig.FCAL_EScale);
                eventobj.position.z = (655 + (eventobj.userData.E * ViewerConfig.FCAL_EScale / 2) + 15);
                eventobj.geometryNeedsUpdate = true;
            }
        }
    }

    function animateFCALShowers(clock,time_scale,eventobj,min_start_time,max_total_time) {
        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "FCALShower") {
            if (eventobj.userData.fTime > ViewerConfig.max_clock_time ||
                eventobj.userData.fTime < ViewerConfig.min_clock_time) {
                eventobj.material.visible = false;
                return;
            }//RESPECT THE CLOCK BOUNDS FCAL Shower
            else {
                if (eventobj.userData.fEnergy > ViewerConfig.FCAL_ShowerEcut && ViewerConfig.FCALShowerVis !== "Off")
                    eventobj.material.visible = true;
            }
            if (ViewerConfig.FCALShowerVis === "Dynamic") {
                if (SceneTime + min_start_time > eventobj.userData.fTime) {
                    eventobj.scale.set(10, 20, 10);
                    eventobj.position.z = eventobj.userData.showerZ + 10;
                    eventobj.geometryNeedsUpdate = true;

                }
                else if (SceneTime + min_start_time < eventobj.userData.fTime && eventobj.scale.z !== 1) {
                    eventobj.scale.set(1, 1, 1);
                    eventobj.position.z = eventobj.userData.showerZ + .5;
                    eventobj.geometryNeedsUpdate = true;
                }
            }
            else if (ViewerConfig.FCALShowerVis === "Off" && eventobj.material.visibile === true) {
                eventobj.material.visibile = false;
            }
            else if (ViewerConfig.FCALShowerVis === "Static" && eventobj.scale.z !== 10) {
                eventobj.scale.set(10, 20, 10);
                eventobj.position.z = eventobj.userData.showerZ + 5;
                eventobj.geometryNeedsUpdate = true;
            }
        }

    }

    function animateTOFHits(clock,time_scale,min_start_time,max_total_time)
    {
        var SceneTime=clock.getElapsedTime()*time_scale;

        if(SceneTime>max_total_time-min_start_time)
        {
            //RealTime=SceneTime;
            SceneTime=max_total_time-min_start_time;
        }

        var eventObj = scene.getObjectByName("GluexGeometry");
        if(eventObj) {


            var geoobjs=eventObj.getObjectByName("FTOF");

            for(var plane=0;plane<geoobjs.children.length;plane++)
            {
                for(var block=0;block<geoobjs.children[plane].children.length;block++)
                {
                    for(var bar=0;bar<geoobjs.children[plane].children[block].children.length;bar++)
                    {

                        if (ViewerConfig.TOFHitVis === "Dynamic" || ViewerConfig.TOFHitVis === "Static" || ViewerConfig.TOFHitVis === "Off") {

                            var numhits0 = 0;
                            var numhits1 = 0;
                            for (var j = 0; j < geoobjs.children[plane].children[block].children[bar].userData.HitTimes.length; j++) {
                                if(geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['time']>ViewerConfig.max_total_time ||
                                    geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['time']<ViewerConfig.min_clock_time)
                                {
                                    continue;
                                }//RESPECT THE CLOCK BOUNDS TOF

                                if (SceneTime + min_start_time >= geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['time'] || ViewerConfig.TOFHitVis === "Static") {

                                    if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['end'] === 0) {
                                        numhits0++;
                                    }
                                    else if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['end'] === 1) {
                                        numhits1++;
                                    }

                                }
                            }


                            for (var end = 0; end <= 1; end++) {

                                var numhits=0;

                                if(end===0)
                                {
                                    numhits=numhits0;
                                }
                                else
                                {
                                    numhits=numhits1;
                                }
                                var colorR = 1;
                                var colorG = 1;
                                var colorB = 1;
                                if (numhits === 0) {
                                    colorR = 1;
                                    colorG = 1;
                                    colorB = 1;

                                }
                                else if (numhits === 1) {
                                    colorR = 1;
                                    colorG = 1;
                                    colorB = 0;
                                    //console.log("first hit");
                                }
                                else if (numhits === 2) {
                                    colorR = 1;
                                    colorG = .66;
                                    colorB = 0;
                                    //console.log("second hit");
                                }
                                else if (numhits === 3) {
                                    colorR = 1;
                                    colorG = 0;
                                    colorB = 0;
                                    //console.log("second hit");
                                }
                                else {
                                    colorR = 1;
                                    colorG = 0;
                                    colorB = 0;
                                }

                                if (ViewerConfig.TOFHitVis === "Off" )
                                {
                                    colorR = 1;
                                    colorG = 1;
                                    colorB = 1;
                                }

                                var face_sent1 = -1;
                                var face_sent2 = -1;

                                if (end === 1) {
                                    face_sent1 = 2;
                                    face_sent2 = 3;
                                } else {
                                    face_sent1 = 0;
                                    //face_sent2 = 0;
                                }

                                var half_length = false;

                                var half_tag =geoobjs.children[plane].children[block].children[bar].name.split("_")[2];
                                if (half_tag==="m21" || half_tag==="m22")
                                    half_length = true;

                                for (var i = 0; i < geoobjs.children[plane].children[block].children[bar].geometry.faces.length; i++) {

                                    if ((i === face_sent1 || i === face_sent2) && !half_length) {
                                        geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.r=colorR;
                                        geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.g=colorG;
                                        geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.b=colorB;
                                        geoobjs.children[plane].children[block].children[bar].geometry.colorsNeedUpdate = true;


                                    }
                                    else {
                                        var sent = 0;
                                        if (end === 1)
                                            sent = 1;

                                        if (i % 2 === sent || half_length) {
                                            geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.r=colorR;
                                            geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.g=colorG;
                                            geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.b=colorB;
                                            geoobjs.children[plane].children[block].children[bar].geometry.colorsNeedUpdate = true;
                                        }
                                    }
                                }
                            }
                        }

                    }

                }

            }

        }
    }

    function animateBCALHits(clock,time_scale,min_start_time,max_total_time) {
        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        var eventObj = scene.getObjectByName("GluexGeometry");
        if (eventObj) {


            var geoobjs = eventObj.getObjectByName("BCAL");

            if (geoobjs) {
                for (var part = 0; part < geoobjs.children.length; part++) {

                    if (geoobjs.children[part].userData.t) {
                        if (geoobjs.children[part].userData.t > ViewerConfig.max_clock_time ||
                            geoobjs.children[part].userData.t < ViewerConfig.min_clock_time) {
                            geoobjs.children[part].material.color.setRGB(1, 1, 1);
                            continue;
                        }//RESPECT THE CLOCK BOUNDS

                        if (ViewerConfig.BCALHitVis === "Dynamic") {
                            if (SceneTime + min_start_time > geoobjs.children[part].userData.t) {
                                geoobjs.children[part].material.color.setRGB(255. / 255., 0. / 255., 0. / 255.);
                            }
                            else if (SceneTime + min_start_time < geoobjs.children[part].userData.t) {
                                geoobjs.children[part].material.color.setRGB(1, 1, 1);
                            }
                        }
                        else if (ViewerConfig.BCALHitVis === "Off") {
                            geoobjs.children[part].material.color.setRGB(1, 1, 1);
                        }
                        else if (ViewerConfig.BCALHitVis === "Static") {
                            if (geoobjs.children[part].userData.t) {
                                geoobjs.children[part].material.color.setRGB(255. / 255., 0. / 255., 0. / 255.);
                            }

                        }
                    }
                }
            }
        }
    }


    function animateTOFPoints(clock,time_scale,eventobj,min_start_time) {
        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "TOFPoint") {
            if (eventobj.userData.t > ViewerConfig.max_clock_time ||
                eventobj.userData.t < ViewerConfig.min_clock_time) {
                eventobj.material.visible = false;
                return;
            }//RESPECT THE CLOCK BOUNDS TOF POINTS
            else {
                if (ViewerConfig.TOFPointVis !== "Off")
                    eventobj.material.visible = true;
            }
            if (ViewerConfig.TOFPointVis === "Dynamic") {
                if (SceneTime + min_start_time > eventobj.userData.t && eventobj.material.color.b === 1) {
                    eventobj.scale.set(3, 3, 3);
                    eventobj.geometryNeedsUpdate = true;
                    eventobj.material.color.r = 1;
                    eventobj.material.color.g = 0;
                    eventobj.material.color.b = 0;
                    eventobj.colorsNeedUpdate = true;
                }
                else if (SceneTime + min_start_time < eventobj.userData.t && eventobj.material.color.r === 1) {
                    eventobj.scale.set(1, 1, 1);
                    eventobj.geometryNeedsUpdate = true;
                    eventobj.material.color.r = 0;
                    eventobj.material.color.g = 0;
                    eventobj.material.color.b = 1;
                    eventobj.colorsNeedUpdate = true;
                }
            }
            else if (ViewerConfig.TOFPointVis === "Off" && eventobj.material.visibile === true) {
                eventobj.material.visible = false;
            }
            else if (ViewerConfig.TOFPointVis === "Static" && eventobj.material.color.r === 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 0;
                eventobj.material.color.g = 0;
                eventobj.material.color.b = 1;
                eventobj.colorsNeedUpdate = true;
            }
        }

    }

    function animateSCHits(eventobjs,clock,time_scale,min_start_time)
    {
        var SceneTime=clock.getElapsedTime()*time_scale;

        if(SceneTime>max_total_time-min_start_time)
        {
            //RealTime=SceneTime;
            SceneTime=max_total_time-min_start_time;
        }

        for (var i = 0; i < eventobjs.length; i++) {
            if (eventobjs[i].userData.t) {
                if(eventobjs[i].userData.t>ViewerConfig.max_clock_time ||
                    eventobjs[i].userData.t<ViewerConfig.min_clock_time)
                {
                    eventobjs[i].material.color.setRGB(1,1,1);
                    continue;
                }//RESPECT THE CLOCK BOUNDS TOF POINTS

                if (ViewerConfig.SCHitVis === "Dynamic") {
                    if (SceneTime + min_start_time > eventobjs[i].userData.t ) {
                        eventobjs[i].material.color.setRGB(255./255., 141./255., 66./255.);
                    }
                    else if (SceneTime + min_start_time < eventobjs[i].userData.t ) {
                        eventobjs[i].material.color.setRGB(1,1,1);
                    }
                }
                else if(ViewerConfig.SCHitVis === "Off")
                {
                    eventobjs[i].material.color.setRGB(1,1,1);
                }
                else if(ViewerConfig.SCHitVis === "Static" )
                {
                    eventobjs[i].material.color.setRGB(255./255., 141./255., 66./255.);
                }
            }
        }
    }

    function animateCDCHits(clock,time_scale,min_start_time)
    {
        var SceneTime=clock.getElapsedTime()*time_scale;

        if(SceneTime>max_total_time-min_start_time)
        {
            //RealTime=SceneTime;
            SceneTime=max_total_time-min_start_time;
        }

        var eventobjs = scene.getObjectByName("CDC").children[0].children;

        for (var i = 0; i < eventobjs.length; i++) {
            if (eventobjs[i].userData.t) {
                if(eventobjs[i].userData.t>ViewerConfig.max_clock_time ||
                    eventobjs[i].userData.t<ViewerConfig.min_clock_time)
                {
                    eventobjs[i].material.visible=false;
                    //continue;
                }//RESPECT THE CLOCK BOUNDS TOF POINTS
                else
                {
                    if(ViewerConfig.CDCHitVis !== "Off")
                        eventobjs[i].material.visible=true;
                }
                if (ViewerConfig.CDCHitVis === "Dynamic") {
                    if (SceneTime + min_start_time > eventobjs[i].userData.t && eventobjs[i].material.visible === false) {
                        eventobjs[i].material.visible = true;
                    }
                    else if (SceneTime + min_start_time < eventobjs[i].userData.t && eventobjs[i].material.visible === true) {
                        eventobjs[i].material.visible = false;
                    }
                }
                else if(ViewerConfig.CDCHitVis === "Off" && eventobjs[i].material.visible===true)
                {
                    eventobjs[i].material.visible=false;
                }
                else if(ViewerConfig.CDCHitVis === "Static" && eventobjs[i].material.visible === false)
                {
                    eventobjs[i].material.visible = true;
                }
            }
        }
    }

    function animateFDCPseudos(clock,time_scale,eventobj,min_start_time) {
        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "FDCPseudo") {
            if (eventobj.userData.time > ViewerConfig.max_clock_time ||
                eventobj.userData.time < ViewerConfig.min_clock_time) {
                eventobj.material.visible = false;
                return;
            }//RESPECT THE CLOCK BOUNDS TOF POINTS
            else {
                if (ViewerConfig.FDCPseudoVis !== "Off")
                    eventobj.material.visible = true;
            }
            if (ViewerConfig.FDCPseudoVis === "Dynamic") {
                if (SceneTime + min_start_time > eventobj.userData.time && eventobj.material.color.b === 1) {
                    eventobj.scale.set(2, 2, 2);
                    eventobj.geometryNeedsUpdate = true;
                    eventobj.material.color.r = 1;
                    eventobj.material.color.g = 0;
                    eventobj.material.color.b = 0;
                    eventobj.colorsNeedUpdate = true;
                }
                else if (SceneTime + min_start_time < eventobj.userData.time && eventobj.material.color.r === 1) {
                    eventobj.scale.set(1, 1, 1);
                    eventobj.geometryNeedsUpdate = true;
                    eventobj.material.color.r = 0;
                    eventobj.material.color.g = 0;
                    eventobj.material.color.b = 1;
                    eventobj.colorsNeedUpdate = true;
                }
            }
            else if (ViewerConfig.FDCPseudoVis === "Off" && eventobj.material.visible === true) {
                eventobj.material.visible = false;
            }
            else if (ViewerConfig.FDCPseudoVis === "Static" && eventobj.material.color.r === 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 0;
                eventobj.material.color.g = 0;
                eventobj.material.color.b = 1;
                eventobj.colorsNeedUpdate = true;
            }
        }

    }

    function animateBCALPoints(clock,time_scale,eventobj,min_start_time) {
        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "BCALPoint") {
            if (eventobj.userData.t > ViewerConfig.max_clock_time ||
                eventobj.userData.t < ViewerConfig.min_clock_time) {
                eventobj.material.visible = false;
                return;
            }//RESPECT THE CLOCK BOUNDS TOF POINTS
            else {
                if (ViewerConfig.BCALPointVis !== "Off")
                    eventobj.material.visible = true;
            }
            if (ViewerConfig.BCALPointVis === "Dynamic") {
                if (SceneTime + min_start_time > eventobj.userData.t && eventobj.material.color.b === 1) {
                    eventobj.scale.set(2, 2, 2);
                    eventobj.geometryNeedsUpdate = true;
                    eventobj.material.color.r = 1;
                    eventobj.material.color.g = 0;
                    eventobj.material.color.b = 0;
                    eventobj.colorsNeedUpdate = true;
                }
                else if (SceneTime + min_start_time < eventobj.userData.t && eventobj.material.color.r === 1) {
                    eventobj.scale.set(1, 1, 1);
                    eventobj.geometryNeedsUpdate = true;
                    eventobj.material.color.r = 0;
                    eventobj.material.color.g = 0;
                    eventobj.material.color.b = 1;
                    eventobj.colorsNeedUpdate = true;
                }
            }
            else if (ViewerConfig.BCALPointVis === "Off" && eventobj.material.visible === true) {
                eventobj.material.visible = false;
            }
            else if (ViewerConfig.BCALPointVis === "Static" && eventobj.material.color.r === 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 0;
                eventobj.material.color.g = 0;
                eventobj.material.color.b = 1;
                eventobj.colorsNeedUpdate = true;
            }
        }
    }

    function animateBCALShowers(clock,time_scale,eventobj,min_start_time,max_total_time) {
        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "BCALShower") {
            if (eventobj.userData.t > ViewerConfig.max_clock_time ||
                eventobj.userData.t < ViewerConfig.min_clock_time) {
                eventobj.material.visible = false;
                return;
            }//RESPECT THE CLOCK BOUNDS BCAL Shower
            else {
                if (eventobj.userData.E > ViewerConfig.BCAL_ShowerEcut && ViewerConfig.BCALShowerVis !== "Off")
                    eventobj.material.visible = true;
            }
            if (ViewerConfig.BCALShowerVis === "Dynamic") {
                if (SceneTime + min_start_time > eventobj.userData.t) {
                    var EScale = 5 + 10 * eventobj.userData.E;
                    eventobj.scale.set(EScale, 2 * EScale, EScale);
                    eventobj.position.z = eventobj.userData.z + EScale;
                    eventobj.geometryNeedsUpdate = true;

                }
                else if (SceneTime + min_start_time < eventobj.userData.t && eventobj.scale.z !== 1) {
                    eventobj.scale.set(1, 1, 1);
                    eventobj.position.z = eventobj.userData.z + .5;
                    eventobj.geometryNeedsUpdate = true;
                }
            }
            else if (ViewerConfig.BCALShowerVis === "Off" && eventobj.material.visibile === true) {
                eventobj.material.visible = false;
            }
            else if (ViewerConfig.BCALShowerVis === "Static" && eventobj.scale.z !== 10) {
                eventobj.scale.set(10, 20, 10);
                eventobj.position.z = eventobj.userData.z + 5;
                eventobj.geometryNeedsUpdate = true;
            }
        }

    }


    function updateClockMessage(clock,time_scale) {

        var SceneTime = clock.getElapsedTime() * time_scale;


        var timeToShow = (min_start_time + SceneTime);
        if (timeToShow > (max_total_time)) {
            timeToShow = max_total_time;
        }
        if(timeToShow<ViewerConfig.min_clock_time)
        {
            timeToShow=ViewerConfig.min_clock_time;
        }
        else if( timeToShow>ViewerConfig.max_clock_time )
        {
            timeToShow=ViewerConfig.max_clock_time;
        }

        var errNum = 99999999999;
        if (ViewerConfig.SceneTimeMessage === errNum.toFixed(3)) {
            $("#EventClock").text("NO HITS IN EVENT");
            //ViewerConfig.SceneTimeMessage = "NO TRACKS IN EVENT"
        }
        else {

            $("#EventClock").text(timeToShow.toFixed(3) + " ns");
        }
    }
    function animateTrackLines(clock,time_scale,min_start_time,eventobj,max_swim_steps,max_swim_time,max_total_time) {

        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {
            //RealTime=SceneTime;
            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "track") {
            var thisGeo = eventobj.children[0].geometry;
            var track_start = (eventobj.userData.start_time);//-min_start_time;
            var draw_count = 0;

            for (; draw_count < max_swim_steps; draw_count++) {
                /*if(SceneTime>ViewerConfig.max_clock_time)
                    {
                        break;
                    }*/
                if (draw_count >= eventobj.userData.steps.length) {
                    break;
                }
                if ((((eventobj.userData.steps[draw_count])[3]) + track_start) > SceneTime + min_start_time) {
                    break;
                }
            }

            if (thisGeo) {
                thisGeo.drawRange.start = 0;

                thisGeo.drawRange.count = draw_count;
                //ViewerConfig.SceneTimeMessage=timeToShow.toFixed(3);


                if ((ViewerConfig.positive_track_line === 'Off' && eventobj.userData.charge === 1) ||
                    (ViewerConfig.negative_track_line === 'Off' && eventobj.userData.charge === -1) ||
                    (ViewerConfig.neutral_track_line === 'Off' && eventobj.userData.charge === 0)) {
                    thisGeo.drawRange.count = 0;
                    //ViewerConfig.SceneTimeMessage = max_total_time.toFixed(3);

                }
                else if ((ViewerConfig.positive_track_line === 'Static' && eventobj.userData.charge === 1) ||
                    (ViewerConfig.negative_track_line === 'Static' && eventobj.userData.charge === -1) ||
                    (ViewerConfig.neutral_track_line === 'Static' && eventobj.userData.charge === 0)) {
                    thisGeo.drawRange.count = max_swim_steps;
                    //ViewerConfig.SceneTimeMessage = max_total_time.toFixed(3);

                }

            }
        }

    }

    function animateFDCHits(clock,time_scale,min_start_time,eventobj,max_swim_steps,max_swim_time,max_total_time) {

        var SceneTime = clock.getElapsedTime() * time_scale;

        if (SceneTime > max_total_time - min_start_time) {

            SceneTime = max_total_time - min_start_time;
        }

        if (eventobj.name.split('_')[0] === "FDCHit") {

            if (eventobj.userData.t > ViewerConfig.max_clock_time ||
                eventobj.userData.t < ViewerConfig.min_clock_time) {
                eventobj.material.visible = false;
                return;
            }//RESPECT THE CLOCK BOUNDS FDCHit
            else {
                if (ViewerConfig.FDCHitVis !== "Off") {
                    eventobj.material.visible = true;
                }
            }

            if (ViewerConfig.FDCHitVis === "Dynamic") {
                if (SceneTime + min_start_time > eventobj.userData.t) {
                    if ((ViewerConfig.FDCHitTypeVis === "Cathodes" && eventobj.userData.type !== 0) || (ViewerConfig.FDCHitTypeVis === "Anodes" && eventobj.userData.type === 0) || ViewerConfig.FDCHitTypeVis === "Both") {
                        eventobj.material.visible = true;
                    }
                    else {
                        eventobj.material.visible = false;
                    }
                }
                else if (SceneTime + min_start_time < eventobj.userData.t && eventobj.material.visible !== false) {
                    eventobj.material.visible = false;
                }
            }
            else if (ViewerConfig.FDCHitVis === "Off" && eventobj.material.visible === true) {
                eventobj.material.visible = false;
            }
            else if (ViewerConfig.FDCHitVis === "Static") {
                if ((ViewerConfig.FDCHitTypeVis === "Cathodes" && eventobj.userData.type !== 0) || (ViewerConfig.FDCHitTypeVis === "Anodes" && eventobj.userData.type === 0) || ViewerConfig.FDCHitTypeVis === "Both") {
                    eventobj.material.visible = true;
                }
                else {
                    eventobj.material.visible = false;
                }

            }
        }
    }

    function UpdateAnimationTriggers(eventobjs)
    {
        max_swim_steps=0;
        max_swim_time=0;
        min_start_time=99999999999;
        max_total_time=-9999999999;
        for (var i = 0; i < eventobjs.length; i++)
        {
            if (eventobjs[i].name.split('_')[0] === "track") {
                if(eventobjs[i].userData.TrackChiSq_NDF>ViewerConfig.TrackingChiSq_NDF_cut
                    && ViewerConfig.TrackingChiSq_NDF_cut !==0)
                {continue;}

                var last_step=(eventobjs[i].userData.steps.length)-1;
                if((eventobjs[i].userData.steps[last_step][3]) > max_swim_time)
                {
                    max_swim_time=(eventobjs[i].userData.steps[last_step][3]);
                }
                if(eventobjs[i].userData.start_time < min_start_time)
                {
                    min_start_time=eventobjs[i].userData.start_time;
                }
                if(eventobjs[i].geometry.vertices.length > max_swim_steps)
                {
                    max_swim_steps=eventobjs[i].geometry.vertices.length;
                }
                if((eventobjs[i].userData.steps[last_step][3])+eventobjs[i].userData.start_time > max_total_time)
                {
                    max_total_time=(eventobjs[i].userData.steps[last_step][3])+eventobjs[i].userData.start_time
                }
            }
            //two tof point classes (in track time...or out) so don't let them contribute to min/max time
            if(ViewerConfig.TOFPointVis !== "Off" && ViewerConfig.TOFPointVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "TOFPoint") {
                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }

            if(ViewerConfig.BCALPointVis !== "Off" && ViewerConfig.BCALPointVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "BCALPoint") {
                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }

            if(ViewerConfig.FCALHitVis !== "Off" && ViewerConfig.FCALHitVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FCALHit") {
                    if(eventobjs[i].userData.E<ViewerConfig.FCAL_HitEcut)
                    {continue;}

                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }


            if(ViewerConfig.FDCHitVis !== "Off" && ViewerConfig.FDCHitVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FDCHit") {

                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }
            if(ViewerConfig.FDCPseudoVis !== "Off" && ViewerConfig.FDCPseudoVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FDCPseudo") {

                    if (eventobjs[i].userData.time < min_start_time) {
                        min_start_time = eventobjs[i].userData.time;
                    }
                    if (eventobjs[i].userData.time > max_total_time) {
                        max_total_time = eventobjs[i].userData.time;
                    }
                }
            }
            if(ViewerConfig.FCALShowerVis !== "Off" && ViewerConfig.FCALShowerVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FCALShower") {
                    if (eventobjs[i].userData.fTime < min_start_time) {
                        min_start_time = eventobjs[i].userData.fTime;
                    }
                    if (eventobjs[i].userData.fTime > max_total_time) {
                        max_total_time = eventobjs[i].userData.fTime;
                    }
                }
            }
            if(ViewerConfig.BCALShowerVis !== "Off" && ViewerConfig.BCALShowerVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "BCALShower") {
                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }
        }
        if(ViewerConfig.BCALHitVis !== "Off" && ViewerConfig.BCALHitVis !=="Static" ) {

            var geoobjs = scene.getObjectByName("BCAL", true);

            //LOOP OVER BCAL AND MAKE THE CHECKS
            if (geoobjs) {
                for (var part = 0; part < geoobjs.children.length; part++) {


                    if (geoobjs.children[part].t < min_start_time) {
                        min_start_time = geoobjs.children[part].t;
                    }
                    if (geoobjs.children[part].t > max_total_time) {
                        max_total_time = geoobjs.children[part].t;
                    }
                }
            }
        }
        if(ViewerConfig.TOFHitVis !== "Off" && ViewerConfig.TOFHitVis !=="Static" ) {

            var geoobjs=scene.getObjectByName("FTOF",true);

            for(var plane=0;plane<geoobjs.children.length;plane++) {
                for (var block = 0; block < geoobjs.children[plane].children.length; block++) {
                    for (var bar = 0; bar < geoobjs.children[plane].children[block].children.length; bar++) {
                        for(var hit=0;hit<geoobjs.children[plane].children[block].children[bar].userData.HitTimes.length;hit++) {

                            if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'] < min_start_time) {
                                min_start_time = geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'];
                            }
                            if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'] > max_total_time) {
                                max_total_time = geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'];
                            }
                        }
                    }
                }
            }
        }
        if(ViewerConfig.CDCHitVis !== "Off" && ViewerConfig.CDCHitVis !=="Static" ) {

            var eventobjs = scene.getObjectByName("CDC").children[0].children;
            var time=9999999999;
            for (var i = 0; i < eventobjs.length; i++) {

                if(eventobjs[i].userData.t) {

                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }

            }
        }
        if(ViewerConfig.SCHitVis !== "Off" && ViewerConfig.SCHitVis !=="Static" ) {

            var eventobjs = scene.getObjectByName("SC").children[0].children;
            var time=9999999999;
            for (var i = 0; i < eventobjs.length; i++) {

                if(eventobjs[i].userData.t) {

                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }

            }
        }

        if(min_start_time<ViewerConfig.min_clock_time)
        {
            min_start_time=ViewerConfig.min_clock_time;
        }
        if(max_total_time>ViewerConfig.max_clock_time)
        {
            max_total_time=ViewerConfig.max_clock_time;
        }

    }

    function animate() {

        requestAnimationFrame( animate );
        var time_scale=ViewerConfig.time_scale;

        if(firstShowing)
        {
            clock.stop();
            clock.start();
        }


        updateClockMessage(clock,time_scale);

        var SceneTime=clock.getElapsedTime()*time_scale;

        var RealTime=SceneTime;

        // console.log(SceneTime);
        controls.update();
        var eventObj = scene.getObjectByName("GluexEvent");
        var geoObj = scene.getObjectByName("GluexGeometry");
        if( eventObj ) {
            var eventobjs = eventObj.children;

            if(ViewerConfig.TimingsNeedsUpdate===true) {
                UpdateAnimationTriggers(eventobjs);
                ViewerConfig.TimingsNeedsUpdate = false;
            }

            if(SceneTime>max_total_time-min_start_time)
            {
                //RealTime=SceneTime;
                SceneTime=max_total_time-min_start_time;
            }

            for(var i=0;i<eventobjs.length;i++) {
                animateTrackLines(clock, time_scale, min_start_time, eventobjs[i], max_swim_steps, max_swim_time, max_total_time);
                animateBCALPoints(clock, time_scale, eventobjs[i], min_start_time);
                animateBCALShowers(clock, time_scale, eventobjs[i], min_start_time, max_total_time);
                animateFDCHits(clock, time_scale, min_start_time, eventobjs[i], max_swim_steps, max_swim_time, max_total_time);
                animateFDCPseudos(clock, time_scale, eventobjs[i], min_start_time);
                animateTOFPoints(clock, time_scale, eventobjs[i], min_start_time);
                animateFCALHits(clock, time_scale, eventobjs[i], min_start_time);
                animateFCALShowers(clock, time_scale, eventobjs[i], min_start_time, max_total_time);
            }
            animateSCHits(scene.getObjectByName("SC").children[0].children,clock, time_scale, min_start_time);
            animateCDCHits(clock, time_scale, min_start_time);
            animateTOFHits(clock, time_scale, min_start_time, max_total_time);
            animateBCALHits(clock, time_scale, min_start_time, max_total_time);


            if((SceneTime+min_start_time>(max_total_time) || firstShowing || RealTime+min_start_time>=max_total_time+2*time_scale))//includes a delay at the end
            {
                if(firstShowing)
                {
                    firstShowing=false;
                }
                clock.stop();
                ViewerConfig.SceneTimeMessage=min_start_time.toFixed(3);
                // required after the first render
                for (var i = 0; i < eventobjs.length; i++) {
                    if (eventobjs[i].name.split('_')[0] === "track") {
                        var thisGeo = eventobjs[i].children[0].geometry;

                        updateTrackPositions(eventobjs[i], max_swim_steps);
                        thisGeo.attributes.position.needsUpdate = true;
                    }
                }

                clock.start();
            }


        }
        render();

    }

    function raytracing()
    {
        /*camera.updateMatrixWorld();

        camera.getWorldDirection( camera_facing );

        orbit_point=camera.position.clone().add(camera_facing.clone().setLength(30));//pretty much an arbitrary length above 10
        controls.target.set(orbit_point.x,orbit_point.y,orbit_point.z);*/

        raycaster.setFromCamera( mouse, camera );
        var event = scene.getObjectByName("GluexEvent");
        var evgeometry = scene.getObjectByName("GluexGeometry");
        if(!event) return;    // There might be no event loaded (yet... or at all)

        var intersects = raycaster.intersectObjects( event.children);// Make improvement

        if ( intersects.length > 0  ) {

            var visible_intersect=false;
            var depth_index=0;
            for(;depth_index<intersects.length;depth_index++)
            {

                if(intersects[depth_index].object.material.visible);
                {
                    visible_intersect=true;
                    break;
                }
            }

            if (intersects[depth_index].object.material.visible) {
                if (INTERSECTED !== intersects[depth_index].object) //you are over an object and it isn't the same one as before (otherwise do nothing)
                {
                    if (INTERSECTED) {
                        //INTERSECTED.material.opacity = 1; //if INTERSECTED is not NULL.  So when you go from A->B without NULL inbetween
                        INTERSECTED.material.wireframe = false;
                    }
                    INTERSECTED = intersects[depth_index].object;  //set the intersected object

                    //INTERSECTED.material.opacity=0;
                    INTERSECTED.material.wireframe = true;

                    if (intersects[depth_index].object.name) {

                        context1.clearRect(0, 0, 1024, 512);
                        var objType = intersects[depth_index].object.name.split("_")[0];
                        var message = intersects[depth_index].object.name.split("_")[1];
                        var userDataList = Object.keys(intersects[0].object.userData);
                        var total_data = userDataList.length;

                        if (objType === "track") {
                            total_data--;
                        }

                        for (var i = 0; i < total_data; i++) {
                            message += ",";
                            message += userDataList[i] + ":";
                            message += intersects[depth_index].object.userData[userDataList[i]];
                        }
                        console.log(message);
                        var metrics = context1.measureText(message);
                        var width = metrics.width;
                        context1.fillStyle = "rgba(0,0,0,0.95)"; // black border
                        context1.fillRect(0, 0, width + 8, 20 + 8);
                        context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
                        context1.fillRect(2, 2, width + 4, 20 + 4);
                        context1.fillStyle = "rgba(0,0,0,1)"; // text color
                        context1.fillText(message, 4, 20);
                        texture1.needsUpdate = true;
                    }
                    else {
                        context1.clearRect(0, 0, 300, 300);
                        texture1.needsUpdate = true;
                    }
                }
            }
        }else {

            if ( INTERSECTED ) {
                INTERSECTED.material.wireframe=false;
            }
            INTERSECTED = null;
            visible_intersect=false;
            context1.clearRect(0,0,300,300);
            texture1.needsUpdate = true;
        }

    }

    function render() {

        if(VRbool)
        {

            if(renderer.vr)
                renderer.vr.enabled = true;

            renderer.render( scene, camera );
            stats.update();
        }
        else {
            // camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
            //renderer.vr.enabled = false;
            if(renderer.vr)
                renderer.vr.enabled = false;

            renderer.render(scene, camera);
            stats.update();

        }

    }

</script>

</body>
</html>
