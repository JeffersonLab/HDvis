<!DOCTYPE html>
<html lang="en">
<head>
    <title>GlueX HDvis -- Dmitry Romanov and Thomas Britton</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
    <link rel="stylesheet" type="text/css" href="dat.gui.css" />
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/FlyControls.js"></script>
<script src="js/libs/stats.min.js"></script>
<script src="js/libs/dat.gui.min.js"></script>
<script src="js/GluexEventLoader.js"></script>
<script src="js/GluexHDDSLoader.js"></script>
<script src="js/effects/StereoEffect.js"></script>
<script src="js/vr/WebVR.js"></script>
<script src="js/threex.geometricglowmesh.js"></script>
<script src="js/threex.dilategeometry.js"></script>
<script src="js/threex.atmospherematerial.js"></script>


<script>




    var container, stats;

    var camera, controls, scene, renderer, raycaster, effect;

    var canvas1, context1, texture1;
    var sprite1;

    var VRbool=false;

    var info;
    // start scene
    var mouse = new THREE.Vector2(), INTERSECTED;

    keyState: new Array();


    if(VRbool)
    {
        WEBVR.checkAvailability().catch( function( message ) {
            document.body.appendChild( WEBVR.getMessageContainer( message ) );
        } );

    }


    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
        camera.position.z = 900;
        camera.position.x=-1000;
        camera.position.y=100;


        scene = new THREE.Scene();

        var light = new THREE.PointLight( 0xffffff, 1.5 );
        light.position.set( 1000, 1000, 2000 );
        scene.add( light );

        scene.add(new THREE.AmbientLight(0xA0A0A0));

        renderer = new THREE.WebGLRenderer( { antialias: true } ); // WebGLRenderer CanvasRenderer
        renderer.setClearColor( 0xff0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        if(renderer.vr)
        {
            WEBVR.getVRDisplay( function ( display ) {
                renderer.vr.setDevice( display );
                document.body.appendChild( WEBVR.getButton( display, renderer.domElement ) );
            } );
        }
        //effect = new THREE.StereoEffect(renderer);
        //effect.setSize(window.innerWidth, window.innerHeight);


        stats = new Stats();
        document.body.appendChild(stats.dom);

        raycaster = new THREE.Raycaster();

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        /*controls = new THREE.FlyControls( camera );
        controls.movementSpeed = 1;
        controls.domElement = container;
        controls.rollSpeed = Math.PI / 24;
        controls.autoForward = false;
        controls.dragToLook = false;*/


        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'keydown', onKeyDown, false );

        var alpha = 0.5;
        var gamma = 0.5;
        var material = new THREE.MeshBasicMaterial( {
            color: new THREE.Color().setHSL( alpha, 0.5, gamma * 0.5 ),
            reflectivity: 0.1,
            shading: THREE.SmoothShading
        } );

        var meshMaterial = new THREE.MeshLambertMaterial( {
            color: 0xffffff,
            opacity: 0.5,
            transparent: true
        } );

        object = new THREE.Mesh( new THREE.SphereGeometry( 75, 20, 10 ), meshMaterial );
        object.position.set( 0, 0, 0 );
        //scene.add( object );


        var geometryLoader = new THREE.GluexHDDSLoader();

        geometryLoader.load('./hdds/main_full_HDDS.xml', function (loadedGeom) {

            var eventLoader = new THREE.GluexEventLoader();
            eventLoader.setGeometry(loadedGeom);
            eventLoader.load('./event.json', function(loadedEvent) {
                scene.add(loadedEvent);
            });

            scene.add(loadedGeom);
        });


        object = new THREE.AxisHelper( 100 );
        object.position.set( 0, 0, 0 );
        scene.add( object );

        renderer.setClearColor( 0x000000 );

        canvas1 = document.createElement('canvas');
        context1 = canvas1.getContext('2d');
        context1.font = "Bold 20px Arial";
        context1.fillStyle = "rgba(0,0,0,0.95)";
        context1.fillText('Hello, world!', 0, 20);

        texture1 = new THREE.Texture(canvas1);
        texture1.minFilter=THREE.LinearFilter;
        texture1.needsUpdate = true;


        var spriteMaterial = new THREE.SpriteMaterial( { map: texture1} );

        sprite1 = new THREE.Sprite( spriteMaterial );
        sprite1.scale.set(512,128,1.0);
        sprite1.position.set( mouse.x, mouse.y, 0 );
        scene.add( sprite1 );


        // ref for lumens: http://www.power-sure.com/lumens.htm

        // Here is our mighty config
        var HDVisConfig = function() {

            this.ftofDetailOptions = {
                "Box only": 'box',
                "Sections": 'sections',
                "Modules":  'modules'
            };

            this.ftofDetail = 'modules'; // "box", "sections", "modules"

            this.positive_tracks=true;
            this.negative_tracks=true;
            this.neutral_tracks=true;
            // Thomas, here is GUI examples:
            // http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage
        };

        var config = new HDVisConfig();


        // GUI----------------------------------------------------------------------------------------
        var gui = new dat.GUI({load: JSON});
        gui.remember(config);


        gui.addFolder('CDC');

        var tofGuiFolder = gui.addFolder('TOF');
        gui.addFolder('FCAL');

        tofGuiFolder
            .add( config, 'ftofDetail', config.ftofDetailOptions )
            .name('Detalization')
            .onFinishChange(function(value) {
                var ftof = scene.getObjectByName("FTOF", true);

                var tofDetails = function(isBoxVisible, isSectionsVisible, isModulesVisible){

                    ftof.children.forEach(function (plane) {
                        plane.material.visible = isBoxVisible;
                        plane.children.forEach(function (region) {
                            region.material.visible = isSectionsVisible;
                            region.children.forEach(function (module) {
                                module.material.visible = isModulesVisible;
                            });
                        });
                    });
                };

                switch(value)
                {
                    case 'box':
                        tofDetails(true, false, false);
                        break;
                    case 'sections':
                        tofDetails(false, true, false);
                        break;
                    case 'modules':
                        tofDetails(false, false, true);
                        break;
                }
                // Fires when a controller loses focus.
                //alert("The new value is " + value);
            });

       var Trackinggui= gui.addFolder('Tracking');

        Trackinggui.add(config, 'positive_tracks', config.positive_tracks).name('Show Positive Tracks')
            .onFinishChange(function(value) {
                var eventobjs = scene.getObjectByName("GluexEvent").children;
                gui_TrackVis(eventobjs,1,value);
            });

        Trackinggui.add(config, 'negative_tracks', config.negative_tracks).name('Show Negative Tracks')
            .onFinishChange(function(value) {
                var eventobjs = scene.getObjectByName("GluexEvent").children;
                gui_TrackVis(eventobjs,-1,value);
            });

        Trackinggui.add(config, 'neutral_tracks', config.neutral_tracks).name('Show Neutral Tracks')
            .onFinishChange(function(value) {
                var eventobjs = scene.getObjectByName("GluexEvent").children;
                gui_TrackVis(eventobjs,0,value);
            });

        //gui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );
        //gui.add( params, 'exposure', 0, 1 );
        //gui.add( params, 'shadows' );
        gui.open();
//------------------------------------------------------------------------------------------------------------------------
    }

    function gui_TrackVis(eventobjs,Trackq,isVis) {

        for(var i=0;i<eventobjs.length;i++)
        {

            if(eventobjs[i].name.split('_')[0]==="track" && eventobjs[i].userData.charge===Trackq)
            {
                eventobjs[i].material.visible=isVis;
            }
        }
    }

    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        //console.log(mouse.x+","+mouse.y)
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onKeyDown(event) {
        var MoveDelta=5;
        switch (event.keyCode) {

            case 86: VRbool = !VRbool;break;//v
            case 87: camera.translateZ(-MoveDelta);camera.updateMatrixWorld();break;//w
            case 83: camera.translateZ(MoveDelta);camera.updateMatrixWorld();break;//s
            case 65: camera.translateX(-MoveDelta);camera.updateMatrixWorld();break;//a
            case 68: camera.translateX(MoveDelta);camera.updateMatrixWorld();break;//d

         }

    }
    //

    function animate() {

        //requestAnimationFrame( animate );

        controls.update();

        renderer.animate( render );
        //render();
        //stats.update();

    }

    function render() {

        //camera.lookAt(scene.position);
        camera.updateMatrixWorld();

        raycaster.setFromCamera( mouse, camera );
        var event = scene.getObjectByName("GluexEvent");
        var evgeometry = scene.getObjectByName("GluexGeometry");
        if(!event) return;    // There might be no event loaded (yet... or at all)

        var intersects = raycaster.intersectObjects( event.children);// Make improvement
        //intersects+=raycaster.intersectObjects( evgeometry.children);
        //console.log(INTERSECTED);

        if ( intersects.length > 0 ) {
            //console.log(intersects.length);
            //console.log(intersects[0].name);

            if ( INTERSECTED !== intersects[ 0 ].object ) //you are over an object and it isn't the same one as before (otherwise do nothing)
            {
                if ( INTERSECTED ) {


                    //INTERSECTED.material.opacity = 1; //if INTERSECTED is not NULL.  So when you go from A->B without NULL inbetween
                    INTERSECTED.material.wireframe=false;
                }
                INTERSECTED = intersects[ 0 ].object;  //set the intersected object

                //INTERSECTED.material.opacity=0;
                INTERSECTED.material.wireframe=true;

                if ( intersects[ 0 ].object.name )
                {

                    context1.clearRect(0,0,1024,512);
                    var message = intersects[ 0 ].object.name;
                    var metrics = context1.measureText(message);
                    var width = metrics.width;
                    context1.fillStyle = "rgba(0,0,0,0.95)"; // black border
                    context1.fillRect( 0,0, width+8,20+8);
                    context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
                    context1.fillRect( 2,2, width+4,20+4 );
                    context1.fillStyle = "rgba(0,0,0,1)"; // text color
                    context1.fillText( message, 4,20 );
                    texture1.needsUpdate = true;
                }
                else
                {
                    context1.clearRect(0,0,300,300);
                    texture1.needsUpdate = true;
                }


            }


        }else {
            //console.log("off of the object");
            if ( INTERSECTED ) {
                //console.log("reset the object");
                //INTERSECTED.material.opacity = 1;
                INTERSECTED.material.wireframe=false;
            }
            INTERSECTED = null;
            context1.clearRect(0,0,300,300);
            texture1.needsUpdate = true;
        }


        if(VRbool)
        {
            
            if(renderer.vr)
                renderer.vr.enabled = true;

            renderer.render( scene, camera );
        }
        else {
           // camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
            //renderer.vr.enabled = false;
            if(renderer.vr)
                renderer.vr.enabled = false;

            renderer.render(scene, camera);
        }
    }

</script>

</body>
</html>
