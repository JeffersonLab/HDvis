<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometry - Subdivisions with Catmull-Clark</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/libs/stats.min.js"></script>
<script src="js/GluexEventLoader.js"></script>
<script src="js/effects/StereoEffect.js"></script>

<script>

    var container, stats;

    var camera, controls, scene, renderer, raycaster, effect;

    var VRbool=false;

    var info;
    // start scene
    var mouse = new THREE.Vector2(), INTERSECTED;

    keyState: new Array();

    init();
    animate();

    function init() {
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
        camera.position.z = 500;

        scene = new THREE.Scene();

        var light = new THREE.PointLight( 0xffffff, 1.5 );
        light.position.set( 1000, 1000, 2000 );
        scene.add( light );

        renderer = new THREE.WebGLRenderer( { antialias: true } ); // WebGLRenderer CanvasRenderer
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );


        effect = new THREE.StereoEffect(renderer);
        effect.setSize(window.innerWidth, window.innerHeight);


        stats = new Stats();
        document.body.appendChild(stats.dom);

        raycaster = new THREE.Raycaster();


        controls = new THREE.OrbitControls( camera, renderer.domElement );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'keydown', onKeyDown, false );

        var alpha = 0.5;
        var gamma = 0.5;
        var material = new THREE.MeshBasicMaterial( {
            color: new THREE.Color().setHSL( alpha, 0.5, gamma * 0.5 ),
            reflectivity: 0.1,
            shading: THREE.SmoothShading
        } );

        var meshMaterial = new THREE.MeshLambertMaterial( {
            color: 0xffffff,
            opacity: 0.5,
            transparent: true
        } );

        object = new THREE.Mesh( new THREE.SphereGeometry( 75, 20, 10 ), meshMaterial );
        object.position.set( 0, 0, 0 );
        //scene.add( object );

        var eventLoader = new THREE.GluexEventLoader();
        eventLoader.load('./event.json', function(objects) {
            scene.add(objects);
        });

        renderer.setClearColor( 0x000000 );

    }

    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        //console.log(mouse.x+","+mouse.y)
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onKeyDown(event) {

        switch (event.keyCode) {

            case 86: VRbool = !VRbool;break;

         }
    }
    //

    function animate() {

        requestAnimationFrame( animate );

        controls.update();

        render();
        stats.update();

    }

    function render() {

        //camera.lookAt(scene.position);
        camera.updateMatrixWorld();

        raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects( scene.children[1].children);// Make improvement

        //console.log(INTERSECTED);

        if ( intersects.length > 0 ) {
            //console.log(intersects.length);
            //console.log(intersects[0].name);

            if ( INTERSECTED !== intersects[ 0 ].object ) //you are over an object and it isn't the same one as before (otherwise do nothing)
            {
                if ( INTERSECTED ) {
                    //INTERSECTED.material.opacity = 1; //if INTERSECTED is not NULL.  So when you go from A->B without NULL inbetween
                    INTERSECTED.material.wireframe=false;
                }
                INTERSECTED = intersects[ 0 ].object;  //set the intersected object

                //INTERSECTED.material.opacity=0;
                INTERSECTED.material.wireframe=true;

            }


        }else {
            //console.log("off of the object");
            if ( INTERSECTED ) {
                //console.log("reset the object");
                //INTERSECTED.material.opacity = 1;
                INTERSECTED.material.wireframe=false;
            }
            INTERSECTED = null;
        }


        if(VRbool)
        {
            effect.render( scene, camera );
        }
        else {
            renderer.render(scene, camera);
        }
    }

</script>

</body>
</html>
