<!DOCTYPE html>
<html lang="en">
<head>
    <title>GlueX HDvis -- Dmitry Romanov and Thomas Britton</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
    <link rel="stylesheet" type="text/css" href="dat.gui.css" />
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/FlyControls.js"></script>
<script src="js/libs/stats.min.js"></script>
<script src="js/libs/dat.gui.min.js"></script>
<script src="js/GluexEventLoader.js"></script>
<script src="js/GluexHDDSLoader.js"></script>
<script src="js/GluexGUI.js"></script>
<script src="js/effects/StereoEffect.js"></script>
<script src="js/vr/WebVR.js"></script>
<script src="js/threex.geometricglowmesh.js"></script>
<script src="js/threex.dilategeometry.js"></script>
<script src="js/threex.atmospherematerial.js"></script>
<script src="js/cameras/CombinedCamera.js"></script>


<script>




    var clock = new THREE.Clock();
    var container, stats;

    var camera,ortho_camera, controls, scene, renderer, raycaster, effect;

    var camera_facing = new THREE.Vector3( 0, 0, -1 );
    var orbit_point=new THREE.Vector3();

    var canvas1, context1, texture1;
    var sprite1;

    var VRbool=false;

    var ViewerConfig;
    var info;
    // start scene
    var mouse = new THREE.Vector2(), INTERSECTED;

    keyState: new Array();
    var drawCount=-1;

    if(VRbool)
    {
        WEBVR.checkAvailability().catch( function( message ) {
            document.body.appendChild( WEBVR.getMessageContainer( message ) );
        } );

    }


    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        //camera = new THREE.CombinedCamera( window.innerWidth / 2, window.innerHeight / 2, 70, 1, 5000, 0, 5000 );
        //camera.toPerspective();
        // camera.toOrthographic();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
        camera.position.z = 371;//900;
        camera.position.x=-625;//-1000;
        camera.position.y=56;//100;




        scene = new THREE.Scene();

        var light = new THREE.PointLight( 0xffffff, 1.5 );
        light.position.set( 1000, 1000, 2000 );
        scene.add( light );

        scene.add(new THREE.AmbientLight(0xA0A0A0));

        renderer = new THREE.WebGLRenderer( { antialias: true } ); // WebGLRenderer CanvasRenderer
        renderer.setClearColor( 0xff0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        if(renderer.vr)
        {
            WEBVR.getVRDisplay( function ( display ) {
                renderer.vr.setDevice( display );
                document.body.appendChild( WEBVR.getButton( display, renderer.domElement ) );
            } );
        }
        //effect = new THREE.StereoEffect(renderer);
        //effect.setSize(window.innerWidth, window.innerHeight);


        stats = new Stats();
        document.body.appendChild(stats.dom);

        raycaster = new THREE.Raycaster();

        controls = new THREE.OrbitControls( camera, renderer.domElement );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'keydown', onKeyDown, false );

        var alpha = 0.5;
        var gamma = 0.5;
        var material = new THREE.MeshBasicMaterial( {
            color: new THREE.Color().setHSL( alpha, 0.5, gamma * 0.5 ),
            reflectivity: 0.1,
            shading: THREE.SmoothShading
        } );

        var meshMaterial = new THREE.MeshLambertMaterial( {
            color: 0xffffff,
            opacity: 0.5,
            transparent: true
        } );

        var geometryLoader = new THREE.GluexHDDSLoader();

        geometryLoader.load('./hdds/main_full_HDDS.xml', function (loadedGeom) {

            var eventLoader = new THREE.GluexEventLoader();
            eventLoader.setGeometry(loadedGeom);
            eventLoader.load('./event.json', function(loadedEvent) {
                scene.add(loadedEvent);
            });

            scene.add(loadedGeom);
        });


        object = new THREE.AxisHelper( 100 );
        object.position.set( 0, 0, 0 );
        scene.add( object );

        renderer.setClearColor( 0x000000 );

        canvas1 = document.createElement('canvas');
        context1 = canvas1.getContext('2d');
        context1.font = "Bold 20px Arial";
        context1.fillStyle = "rgba(0,0,0,0.95)";
        context1.fillText('Hello, world!', 0, 20);

        texture1 = new THREE.Texture(canvas1);
        texture1.minFilter=THREE.LinearFilter;
        texture1.needsUpdate = true;


        var spriteMaterial = new THREE.SpriteMaterial( { map: texture1} );

        sprite1 = new THREE.Sprite( spriteMaterial );
        sprite1.scale.set(512,128,1.0);
        sprite1.position.set( mouse.x, mouse.y, 0 );
        scene.add( sprite1 );


        // ref for lumens: http://www.power-sure.com/lumens.htm

        // Here is our mighty config

        // GUI----------------------------------------------------------------------------------------
        ViewerConfig=makeGUI();
    }



    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        //console.log(mouse.x+","+mouse.y)
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onKeyDown(event) {
        var MoveDelta=10;
        switch (event.keyCode) {

            case 86: VRbool = !VRbool;break;//v
            case 87: camera.translateZ(-MoveDelta);camera.updateMatrixWorld();break;//w
            case 83: camera.translateZ(MoveDelta);camera.updateMatrixWorld();break;//s
            case 65: camera.translateX(-MoveDelta);camera.updateMatrixWorld();break;//a
            case 68: camera.translateX(MoveDelta);camera.updateMatrixWorld();break;//d
            case 32: camera.translateY(MoveDelta);camera.updateMatrixWorld();break;//spacebar
            case 90: camera.translateY(-MoveDelta);camera.updateMatrixWorld();break;//z

         }

    }
    //
    function updatePositions(lineGeo) {
        var positions = lineGeo.children[0].geometry.attributes.position.array;
        var parent=lineGeo.geometry.vertices;
        var limit=parent.length;
        var index = 0;
        for ( var i = 0; i<1000; i ++ ) {
            if(parent[i]) {
                positions[index++] = parent[i].x;
                positions[index++] = parent[i].y;
                positions[index++] = parent[i].z;
            }
            else
            {
                positions[index++] = parent[limit-1].x;
                positions[index++] = parent[limit-1].y;
                positions[index++] = parent[limit-1].z;
            }
        }
    }

    function animate() {

        requestAnimationFrame( animate );
        drawCount = ( drawCount + 1 ) % 1000;
        controls.update();
        if(scene.getObjectByName("GluexEvent")) {
            var eventobjs = scene.getObjectByName("GluexEvent").children;
            for (var i = 0; i < eventobjs.length; i++) {
                if (eventobjs[i].name.split('_')[0] === "track") {
                    var thisGeo=eventobjs[i].children[0].geometry;
                    if(thisGeo) {
                        thisGeo.drawRange.start = 0;
                        thisGeo.drawRange.count = drawCount;
                        if (drawCount === 0) {
                            // periodically, generate new data
                            updatePositions(eventobjs[i]);
                            thisGeo.attributes.position.needsUpdate = true; // required after the first render
                        }
                    }
                }
            }
        }
        //renderer.animate( render );
        render();
        stats.update();
    }

    function render() {

        //camera.lookAt(scene.position);
        //ortho_camera.updateMatrixWorld();
        camera.updateMatrixWorld();

        camera.getWorldDirection( camera_facing );

        orbit_point=camera.position.clone().add(camera_facing.clone().setLength(30));//pretty much an arbitrary length above 10
        controls.target.set(orbit_point.x,orbit_point.y,orbit_point.z);

        raycaster.setFromCamera( mouse, camera );
        var event = scene.getObjectByName("GluexEvent");
        var evgeometry = scene.getObjectByName("GluexGeometry");
        if(!event) return;    // There might be no event loaded (yet... or at all)

        var intersects = raycaster.intersectObjects( event.children);// Make improvement
        //intersects+=raycaster.intersectObjects( evgeometry.children);
        //console.log(INTERSECTED);

        if ( intersects.length > 0 ) {
            //console.log(intersects.length);
            //console.log(intersects[0].name);

            if ( INTERSECTED !== intersects[ 0 ].object ) //you are over an object and it isn't the same one as before (otherwise do nothing)
            {
                if ( INTERSECTED ) {


                    //INTERSECTED.material.opacity = 1; //if INTERSECTED is not NULL.  So when you go from A->B without NULL inbetween
                    INTERSECTED.material.wireframe=false;
                }
                INTERSECTED = intersects[ 0 ].object;  //set the intersected object

                //INTERSECTED.material.opacity=0;
                INTERSECTED.material.wireframe=true;

                if ( intersects[ 0 ].object.name )
                {

                    context1.clearRect(0,0,1024,512);
                    var userDataList=Object.keys(intersects[ 0 ].object.userData);
                    var message = intersects[ 0 ].object.name.split("_")[1];
                    for(var i=0;i<userDataList.length;i++)
                    {
                        message+=",";
                        message+=userDataList[i]+":";
                        message+=intersects[ 0 ].object.userData[userDataList[i]];
                    }
                    console.log(message);
                    var metrics = context1.measureText(message);
                    var width = metrics.width;
                    context1.fillStyle = "rgba(0,0,0,0.95)"; // black border
                    context1.fillRect( 0,0, width+8,20+8);
                    context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
                    context1.fillRect( 2,2, width+4,20+4 );
                    context1.fillStyle = "rgba(0,0,0,1)"; // text color
                    context1.fillText( message, 4,20 );
                    texture1.needsUpdate = true;
                }
                else
                {
                    context1.clearRect(0,0,300,300);
                    texture1.needsUpdate = true;
                }


            }


        }else {
            //console.log("off of the object");
            if ( INTERSECTED ) {
                //console.log("reset the object");
                //INTERSECTED.material.opacity = 1;
                INTERSECTED.material.wireframe=false;
            }
            INTERSECTED = null;
            context1.clearRect(0,0,300,300);
            texture1.needsUpdate = true;
        }


        //scroll through vertices making visible
/*        if(scene.getObjectByName("GluexEvent") && (clock.elapsedTime/10)%2===0) {
            var eventobjs = scene.getObjectByName("GluexEvent").children;
            for (var i = 0; i < eventobjs.length; i++) {
                if (eventobjs[i].name.split('_')[0] === "track") {
                    var trackverticies = eventobjs[i].geometry.vertices;

                    for (var j = 0; j < trackverticies.length; j++) {
                        if (!trackverticies[j].visibility) {
                            trackverticies[j].visibility = true;
                            eventobjs[i].geometry.needsUpdate = true;
                            break;
                        }
                        else
                        {
                            trackverticies[j].visibility = false;
                            eventobjs[i].geometry.needsUpdate = true;
                        }
                    }
                }
            }
        }
*/
        if(VRbool)
        {
            
            if(renderer.vr)
                renderer.vr.enabled = true;

            renderer.render( scene, camera );

        }
        else {
           // camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
            //renderer.vr.enabled = false;
            if(renderer.vr)
                renderer.vr.enabled = false;

            renderer.render(scene, camera);

        }
    }

</script>

</body>
</html>
