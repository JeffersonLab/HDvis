<!DOCTYPE html>
<html lang="en">
<head>
    <title>GlueX HDvis -- Dmitry Romanov and Thomas Britton</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            margin: 0px;
            overflow: hidden;
            /*background: #f0f0f0 url("background_dark1.jpg");*/
        }


        .button {
            display: inline-block;
            position: relative;
            margin: 10px;
            padding: 0 20px;
            text-align: center;
            text-decoration: none;
            font: bold 12px/25px Arial, sans-serif;

            text-shadow: 1px 1px 1px rgba(255,255,255, .22);

            -webkit-border-radius: 30px;
            -moz-border-radius: 30px;
            border-radius: 30px;

            -webkit-box-shadow: 1px 1px 1px rgba(0,0,0, .29), inset 1px 1px 1px rgba(255,255,255, .44);
            -moz-box-shadow: 1px 1px 1px rgba(0,0,0, .29), inset 1px 1px 1px rgba(255,255,255, .44);
            box-shadow: 1px 1px 1px rgba(0,0,0, .29), inset 1px 1px 1px rgba(255,255,255, .44);

            -webkit-transition: all 0.15s ease;
            -moz-transition: all 0.15s ease;
            -o-transition: all 0.15s ease;
            -ms-transition: all 0.15s ease;
            transition: all 0.15s ease;
        }

        /* Green Color */

        .green {
            color: #3e5706;

            background: #a5cd4e; /* Old browsers */
            background: -moz-linear-gradient(top,  #a5cd4e 0%, #6b8f1a 100%); /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#a5cd4e), color-stop(100%,#6b8f1a)); /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* Opera 11.10+ */
            background: -ms-linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* IE10+ */
            background: linear-gradient(top,  #a5cd4e 0%,#6b8f1a 100%); /* W3C */
        }

        /* Blue Color */

        .blue {
            color: #19667d;

            background: #70c9e3; /* Old browsers */
            background: -moz-linear-gradient(top,  #70c9e3 0%, #39a0be 100%); /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#70c9e3), color-stop(100%,#39a0be)); /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* Opera 11.10+ */
            background: -ms-linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* IE10+ */
            background: linear-gradient(top,  #70c9e3 0%,#39a0be 100%); /* W3C */
        }

        /* Gray Color */

        .gray {
            color: #515151;

            background: #d3d3d3; /* Old browsers */
            background: -moz-linear-gradient(top,  #d3d3d3 0%, #8a8a8a 100%); /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#d3d3d3), color-stop(100%,#8a8a8a)); /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* Opera 11.10+ */
            background: -ms-linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* IE10+ */
            background: linear-gradient(top,  #d3d3d3 0%,#8a8a8a 100%); /* W3C */
        }

        .button:hover {
            -webkit-box-shadow: 1px 1px 1px rgba(0,0,0,.29), inset 0px 0px 2px rgba(0,0,0, .5);
            -moz-box-shadow: 1px 1px 1px rgba(0,0,0,.29), inset 0px 0px 2px rgba(0,0,0, .5);
            box-shadow: 1px 1px 1px rgba(0,0,0,.29), inset 0px 0px 2px rgba(0,0,0, .5);
        }

        .button:active {
            -webkit-box-shadow: inset 0px 0px 3px rgba(0,0,0, .8);
            -moz-box-shadow: inset 0px 0px 3px rgba(0,0,0, .8);
            box-shadow: inset 0px 0px 3px rgba(0,0,0, .8);
        }

        #canvas {
            background-color: #000;
            width: 200px;
            height: 200px;
            border: 1px solid black;
            margin: 100px;
            padding: 0px;
            /*position: static; /* fixed or static */
            top: 100px;
            left: 100px;
        }


        .slidecontainer {
            width: 100%; /* Width of the outside container */
        }

        /* The slider itself */
        .slider {
            -webkit-appearance: none;  /* Override default CSS styles */
            appearance: none;
            width: 100%; /* Full-width */
            height: 25px; /* Specified height */
            background: #d3d3d3; /* Grey background */
            outline: none; /* Remove outline */
            opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
            -webkit-transition: .2s; /* 0.2 seconds transition on hover */
            transition: opacity .2s;
        }

        /* Mouse-over effects */
        .slider:hover {
            opacity: 1; /* Fully shown on mouse-over */
        }

        /* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            width: 10px; /* Set a specific slider handle width */
            height: 35px; /* Slider handle height */
            background: #4CAF50; /* Green background */
            cursor: pointer; /* Cursor on hover */
        }

        .slider::-moz-range-thumb {
            width: 10px; /* Set a specific slider handle width */
            height: 35px; /* Slider handle height */
            background: #4CAF50; /* Green background */
            cursor: pointer; /* Cursor on hover */
        }

    </style>
    <link rel="stylesheet" type="text/css" href="dat.gui.css" />

</head>
<body id="body">


<script src="js/vr/WebVR.js"></script>
<script src="js/three.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/DeviceOrientationControls.js"></script>
<script src="js/libs/stats.min.js"></script>
<script src="js/libs/dat.gui.min.js"></script>
<script src="js/GluexEventLoader.js"></script>
<script src="js/GluexHDDSLoader.js"></script>
<script src="js/GluexGUI.js"></script>
<script src="js/effects/StereoEffect.js"></script>
<script src="js/effects/VREffect.js"></script>
<script src="js/cameras/CombinedCamera.js"></script>
<script src="js/controls/TrackballControls.js"></script>


<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/FXAAShader.js"></script>
<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/OutlinePass.js"></script>


<script src="js/jquery-3.2.1.min.js"></script>
<script src="js/contextMenu.js-master/contextMenu.js"></script>
<link href="js/contextMenu.js-master/contextMenu.css" rel="stylesheet" type="text/css" />



<script src="js/vr/OculusRiftEffect.js"></script>
<!--<script src="js/threex.geometricglowmesh.js"></script>-->
<!--<script src="js/threex.dilategeometry.js"></script>-->
<!--<script src="js/threex.atmospherematerial.js"></script>-->
<!--<script src="js/cameras/CombinedCamera.js"></script>-->
<script src="js/effects/AsciiEffect.js"></script>
<script src="js/effects/VREffect.js"></script>
<script src="js/vr/WebVRCamera.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/vr/WebVR.js"></script>

<!--<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>-->

<nav style="position:absolute; left: 0px; z-index: 100">
    <!--<a href="#" class="button green">button</a>-->

    <!--<a href="#" class="button blue">button</a>-->
    <img src="./gluex_logo.png">
    <a href="#" class="button gray" OnClick="Offlinenext_click()">next</a>
    <!--<a id="autoPlay" href="#" class="button gray" OnClick="autoplay_click()">autoplay</a>-->
    <!--<span id="janaStatus" style="color: darkgray"> JANA status </span>-->
    <span style="display: block; text-align: center;color: green; font-size: 30px" id="EventClock" > Event Clock  </span>
    <div class="slidecontainer">
        <input type="range" min="1" max="100" value="50" class="slider" id="myRange" oninput="SetSceneTime(this.value);doAnimation()" />
    </div>
    <span style="display: block; text-align: center;color: green; font-size: 30px" id="play_pause" > <a href="#" class="button gray" OnClick="togglePlay()">play/pause</a> </span>
    <div style="position: absolute; top: 225px; left: 0px; width: 1000px; white-space: pre-line;" id="ObjectInfo"> </div>

</nav>
<script>



    function updateProgressBar() {
        var slider=document.getElementById('myRange');

        var percentage = Math.floor((100 / (ViewerConfig.max_clock_time-ViewerConfig.min_clock_time)) *
            (SceneClock-ViewerConfig.min_clock_time));

        slider.value=percentage;
    }

    function togglePlay(){
        if(isPlaying)
        {
            SceneClockOffset=parseFloat($("#EventClock")[0].innerHTML.split(" "));//.getElapsedTime()*ViewerConfig.time_scale;
            clock.stop();
            isPlaying=false;

        }
        else
        {
            clock.start();
            isPlaying = true;
            updateClockMessage(clock,ViewerConfig.time_scale);
        }
    }

    function next_click() {
        console.log("calling /api/v1/next");
        firstShowing=true;
        clock.stop();
        var xhr = new XMLHttpRequest();
        previousJanaState = "Processing";
        xhr.open('GET', "/api/v1/next", true);
        xhr.send();

        cleanGeometry(scene,gluexGeometry);
        clock.start();

    }
    function Offlinenext_click() {
        next_click_count++;
        console.log("calling /api/v1/next");
        firstShowing=true;
        clock.stop();

        cleanGeometry(scene,gluexGeometry);
        var fileStr='event_'+next_click_count.toString()+".json";
        loadEventFromFile(fileStr);
        clock.start();

    }
        function autoplay_click() {
        console.log("calling /api/v1/autoplay-on");
        var xhr = new XMLHttpRequest();
        xhr.open('GET', "/api/v1/autoplay-on", true);
        xhr.send();
    }
</script>

<script>
    var previousJanaState = "";


    /*(function poll() {
        //alert("hey");
        $.ajax({
            url: "/api/v1/status",
            type: "GET",
            success: function(data) {

                var message = "JANA: " + data.janaState + " event: " + data.eventNumber.toString();

                if(data.janaState === "Idle" && previousJanaState!== "Idle") {
                    loadEventFromFile('event.json');
                }

                previousJanaState = data.janaState;

                console.log("polling result => " + message);
                if(data.isAutoPlay) {
                    if($("#autoPlay").hasClass("gray")){
                        $("#autoPlay").removeClass("gray").addClass("green");
                    }
                }
                $("#janaStatus").text(message);
            },
            dataType: "json",
            complete: setTimeout(function() {poll()}, 1000),
            timeout: 2000
        })
    })();*/

    var clock = new THREE.Clock();
    var container, stats;

    var camera_in_use,combinedcamera, perspec_camera,webVRCamera, controls_in_use, scene, shadowgeom, shadowevent, renderer, raycaster;
    var player;
    var ASCIIEffect,StereoEffect,OculusEffect;
    var regcontrols,asciicontrols,stereocontrols,perspecregcontrols;
    var outlinePass,composer,effectFXAA;

    var camera_facing = new THREE.Vector3( 0, 0, -1 );
    var recordedCamera_facing = new THREE.Vector3( 0, 0, -1 );
    var orbit_point=new THREE.Vector3();

    var canvas1, context1;

    var firstShowing=true;
    var VRbool=false;
    var asciibool=false;
    var stereobool=false;
    var orthobool=false;

    var ViewerConfig;

    var mouse = new THREE.Vector2();
    var INTERSECTED_OBJECT=null;
    var ObjectLock=false;

    var gluexGeometry = null;

    var SceneClock=0;
    var SceneClockOffset=0.;
    var isPlaying=true;
    var max_swim_steps=0;
    var max_swim_time=0;
    var min_start_time=99999999999;
    var max_total_time=-9999999999;

    var taptimeout;
    var lastTap = 0;
    var next_click_count=1;
    var selectedObjects = [];

    var attached_camera=false;
    var attached_name="track_Electron Track Points 3";

    keyState: new Array();

    //WEBVR.checkAvailability().catch(function (message) {document.body.appendChild(WEBVR.getMessageContainer(message))});

    function switchToOrtho()
    {
        orthobool=true;
        camera_in_use.toOrthographic();

        resetWindowSize();camera_in_use.setZoom(1);controls_in_use.update();camera_in_use.updateMatrixWorld();camera_in_use.updateProjectionMatrix();
    }
    function switchToPerspec()
    {
        orthobool=false;
        camera_in_use.toPerspective();

        resetWindowSize();camera_in_use.setZoom(1);controls_in_use.update();camera_in_use.updateMatrixWorld();camera_in_use.updateProjectionMatrix();
    }

    function snapTo(x,y,z,fx,fy,fz)
    {
        combinedcamera.position.z =z;// 371;
        combinedcamera.position.x=x;//-625;
        combinedcamera.position.y=y;//56;

        player.position.z =z;// 371;
        player.position.x=x;//-625;
        player.position.y=y;//56;

       /* if(webVRCamera) {
            webVRCamera.position.x = x;
            webVRCamera.position.y = y;
            webVRCamera.position.z = z;
        }*/
        combinedcamera.lookAt(new THREE.Vector3(fx,fy,fz));
        perspec_camera.lookAt(new THREE.Vector3(fx,fy,fz));


        camera_facing.x=fx;
        camera_facing.y=fy;
        camera_facing.z=fz;
        RecordCameraFacing();

        resetOrbitPoint(controls_in_use,camera_in_use,camera_facing);

        combinedcamera.updateMatrixWorld();
        perspec_camera.updateMatrixWorld();

    }

    var generic_menu = [
        {
            name: 'camera',
            subMenu:[{
                name: "Camera Type",
                subMenu: [
                    {
                        name: "Orthographic",
                        title: "Orthographic",
                        fun: function(){ switchToOrtho() }
                    },
                    {
                        name: "Perspective",
                        title: "Perspective",
                        fun: function(){ switchToPerspec() }
                    }

                ]
            },
                {
                    name: "Snap To",
                    subMenu: [
                        {
                            name: "Origin",
                            title: "Origin",
                            fun: function(){ snapTo(0,0,0,0,0,1000) }
                        },
                        {
                            name: "TOF",
                            title: "TOF",
                            fun: function(){ snapTo(2.7,7.6,427,0,0,1000) }
                        }
                        ,
                        {
                            name: "FCAL",
                            title: "FCAL",
                            fun: function(){ snapTo(0,0,885,0,0,0) }
                        },
                        {
                            name: "Barrel Top",
                            title: "Barrel Top",
                            fun: function(){ snapTo(0,370,210,0,0,210) }
                        },
                        {
                            name: "Barrel Downstream",
                            title: "Barrel Downstream",
                            fun: function(){ snapTo(0,0,500,0,0,0) }
                        }

                    ]
                }]

        }
    ];

    var tracking_menu = [
        {
            name: 'Hypotheses',
            title: 'Hypotheses',
            subMenu: []

        }
    ];

    var settings =  {
        triggerOn:'contextmenu'
    };

    var menu_to_use;

    init();
    animate();

    function recursiveRemove(mesh) {
        while (mesh.children.length > 0) {
            var child = mesh.children[0];
            recursiveRemove(child);
            mesh.remove(child);
        }
    }

    function loadEventFromFile(fileStr) {
        if(!gluexGeometry){
            console.info("Can't load event because geometry is still not loaded");
            return;
        }

        // hard cleanup!
        var existingGeometry = scene.getObjectByName('GluexGeometry');
        var event = scene.getObjectByName('GluexEvent');
        if(!existingGeometry) {
            gluexGeometry = shadowgeom.clone();
            //shadowgeom=gluexGeometry.clone();
            //cleanGeometry(scene, gluexGeometry);

            scene.add(gluexGeometry);
        }
        if(event) {
            recursiveRemove(event);
            scene.remove(event);
        }

        cleanGeometry(scene,gluexGeometry);
        var eventLoader = new THREE.GluexEventLoader();
        //var shadoweventLoader = new THREE.GluexEventLoader();
        eventLoader.setConfiguration(ViewerConfig);
        eventLoader.setGeometry(gluexGeometry,shadowgeom);
        //shadoweventLoader.setGeometry(gluexGeometry);
        eventLoader.load(fileStr, function(loadedEvent) {
            /* if(shadowevent)
             {
                 recursiveRemove(shadowevent);
             }*/
            var newEvent=loadedEvent;
            scene.add(newEvent);
            UpdateAnimationTriggers(newEvent.children);//loadedEvent.children);
        });

        firstShowing=true;
        SceneClockOffset=min_start_time;

    }

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );



        scene = new THREE.Scene();

        //Lights!
        var ambientLight=new THREE.AmbientLight(0xFFFFFF);

        scene.add(ambientLight);

        //Camera

        combinedcamera = new THREE.CombinedCamera( window.innerWidth / 2, window.innerHeight / 2, 70, 1, 1000, - 500, 1000 );
        combinedcamera.toPerspective();
        //camera_in_use.toOrthographic();


        perspec_camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );


        //camera_in_use=ortho_camera;//perspec_camera;
        //combinedcamera.add(perspec_camera);
       player=new THREE.Object3D();

        player.add(perspec_camera);

        scene.add(player);
        combinedcamera.position.z =510;// 371;
        combinedcamera.position.x=13;//-625;
        combinedcamera.position.y=0;//56;

        player.position.z =510;// 371;
        player.position.x=13;//-625;
        player.position.y=0;//56;


        camera_in_use=combinedcamera;
        // camera.position.z =762;// 371;
        // camera.position.x=-510;//-625;
        // camera.position.y=33;//56;

        //Action

        renderer = new THREE.WebGLRenderer( { antialias: false } ); // WebGLRenderer CanvasRenderer
        renderer.setPixelRatio(1);//window.devicePixelRatio );
        renderer.setSize( window.innerWidth || 1, window.innerHeight || 1 );
        renderer.shadowMap.enabled=false;
        //renderer.precision="lowp";
        renderer.shadowMapAutoUpdate = false;
        renderer.setClearColor( 0x000000 );
        document.body.appendChild( renderer.domElement );
        //renderer.autoClear = false;
        renderer.vr.enabled  = false;

        regcontrols = new THREE.OrbitControls( camera_in_use, renderer.domElement );
        perspecregcontrols = new THREE.OrbitControls( perspec_camera, renderer.domElement );

        //---ASCII---
        ASCIIEffect = new THREE.AsciiEffect( renderer );
        ASCIIEffect.setSize( window.innerWidth || 1, window.innerHeight || 1 );
        ASCIIEffect.shadowMapAutoUpdate = false;

        asciicontrols = new THREE.OrbitControls( camera_in_use, ASCIIEffect.domElement );


        //---STEREO---
        StereoEffect = new THREE.StereoEffect( renderer );
        StereoEffect.setSize( window.innerWidth, window.innerHeight );
        StereoEffect.shadowMapAutoUpdate = false;
        StereoEffect.setEyeSeparation(.1);//make variable

        stereocontrols= new THREE.DeviceOrientationControls(perspec_camera);

        /*OculusEffect =new THREE.OculusRiftEffect(
            renderer,
            {worldScale: 100}); new THREE.VREffect(renderer);
        OculusEffect.setSize( window.innerWidth || 1, window.innerHeight || 1);
        OculusEffect.shadowMapAutoUpdate = false;*/

       // if(renderer.vr) {
        /*WEBVR.getVRDisplay(function (display) {
            renderer.vr.setDevice(display);
           //webVRCamera = new THREE.WebVRCamera(display,renderer);
            //webVRCamera.updateMatrixWorld();
            scene.add(webVRCamera);
            webVRCamera.position.x=13;
            webVRCamera.position.y=0;
            webVRCamera.position.z=510;

            document.body.appendChild(WEBVR.getButton(display, renderer.domElement)); //THIS SHOULD ONLY SPAWN WHEN WANTED
        });*/
        //}
        WEBVR.getVRDisplay( function( display ){
            renderer.vr.setDevice( display );
            document.body.appendChild( WEBVR.getButton( display, renderer.domElement ))
        });



        //------POST--------
        composer = new THREE.EffectComposer(renderer);

        var renderPass = new THREE.RenderPass(scene,camera_in_use);
        composer.addPass( renderPass );

        outlinePass = new THREE.OutlinePass( new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera_in_use);
        composer.addPass( outlinePass );
        outlinePass.edgeStrength=10;
        outlinePass.edgeGlow=0;
        outlinePass.edgeThickness=3;
        outlinePass.pulsePeriod=0;

        outlinePass.usePatternTexture=false;

        outlinePass.visibleEdgeColor.r=1;
        outlinePass.visibleEdgeColor.g=1;
        outlinePass.visibleEdgeColor.b=1;

        outlinePass.hiddenEdgeColor.r=.1;
        outlinePass.hiddenEdgeColor.g=.04;
        outlinePass.hiddenEdgeColor.b=.02;


        effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
        effectFXAA.renderToScreen = true;
        composer.addPass( effectFXAA );

        //---DEFAULT CONTROLS/RENDERING
        controls_in_use=regcontrols;
        container.appendChild( renderer.domElement );

        //stats = new Stats();
        //document.body.appendChild(stats.dom);

        raycaster = new THREE.Raycaster();

        camera_in_use.updateMatrixWorld();
        perspec_camera.updateMatrixWorld();

        resetOrbitPoint(controls_in_use, camera_in_use, camera_facing);
        resetOrbitPoint(perspecregcontrols, perspec_camera, camera_facing);

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'keydown', onKeyDown, false );
        document.addEventListener('mouseup',SelectObject,false);
        document.addEventListener('mousedown',RecordCameraFacing,false);
        //$(document).bind("contextmenu",function(event){DisplayContextMenu(event);});
        //document.addEventListener('contextmenu',DisplayContextMenu,false);


        document.addEventListener('touchend',function(event){
            var currentTime = new Date().getTime();
            var tapLength = currentTime - lastTap;
            clearTimeout(taptimeout);
            if (tapLength < 500 && tapLength > 0) {
                if(stereobool)
                {
                    resetWindowSize();
                    controls_in_use=regcontrols;
                    stereobool=false;
                }
                else
                {
                    stereobool=true;
                    controls_in_use=stereocontrols;
                }
                event.preventDefault();
            } else {
                taptimeout = setTimeout(function() {
                    clearTimeout(taptimeout);
                }, 500);
            }
            lastTap = currentTime;} );

        //--GEOMETRY----

        var geometryLoader = new THREE.GluexHDDSLoader();
        geometryLoader.load('./hdds/main_full_HDDS.xml', function (loadedGeom) {
            shadowgeom = loadedGeom;
            gluexGeometry = loadedGeom.clone();
            // when we have a geometry, we can load the event
            loadEventFromFile('event_'+next_click_count.toString()+".json");
        });

         /*     object = new THREE.AxisHelper( 100 );
               object.position.set( 0, 0, 0 );
        scene.add( object );*/


        canvas1 = document.createElement('canvas');

        context1 = canvas1.getContext('2d');
        context1.font = "Bold 20px Arial";
        context1.fillStyle = "rgba(0,0,0,0.95)";
        context1.fillText('', 0, 20);

        menu_to_use=generic_menu;
        $('body').contextMenu(menu_to_use,settings);
        // GUI----------------------------------------------------------------------------------------
        ViewerConfig=makeGUI(scene);
    }

    function RecordCameraFacing()
    {
        camera_in_use.getWorldDirection(recordedCamera_facing);

    }
    function DisplayContextMenu(valid_intersect)
    {
        if(!valid_intersect)
        {
            menu_to_use=generic_menu;
            $('body').contextMenu(generic_menu,settings);
        }
        else if (valid_intersect.name.split("_")[0] === "track") {

            tracking_menu[0].subMenu=[];
            var hypolist=valid_intersect.userData['track_hypos'];
            for(var hypo_index=0;hypo_index<hypolist.length;hypo_index++)
            {
                const name = hypolist[hypo_index].id;
                tracking_menu[0].subMenu.push({name: hypolist[hypo_index].id.split(" ")[0], title: hypolist[hypo_index].id.split(" ")[0], fun: function(){
                        ChangeTrackHypoTo(valid_intersect, name)}})

            }

            menu_to_use=tracking_menu;
            $('body').contextMenu(tracking_menu, settings);
        }
        else
        {
            menu_to_use=generic_menu;
            $('body').contextMenu(generic_menu,settings);
        }
    }
    function SelectObject(event)
    {

        if(event.button===0 )
        {
            if(!ObjectLock)
            {
                INTERSECTED_OBJECT=raytracing(event);
                if(INTERSECTED_OBJECT!==null) {
                    ObjectLock = true;
                }
            }
            else
            {
                camera_in_use.getWorldDirection(camera_facing);
                if(camera_facing.x===recordedCamera_facing.x && camera_facing.y===recordedCamera_facing.y && camera_facing.z===recordedCamera_facing.z)
                {
                    INTERSECTED_OBJECT = raytracing(event);

                    if (INTERSECTED_OBJECT !== null) {
                        ObjectLock = true;
                    }
                    else {
                        ObjectLock = false
                    }
                }
                else {

                }
            }

        }
        /*else if(event.button===2 )
        {

            camera_in_use.getWorldDirection(camera_facing);
            if(camera_facing.x===recordedCamera_facing.x && camera_facing.y===recordedCamera_facing.y && camera_facing.z===recordedCamera_facing.z)
            {
                DisplayContextMenu(event);
                //INTERSECTED_OBJECT = raytracing(event);
                //if (INTERSECTED_OBJECT !== null) {
                //menu

                //}

            }

        }*/


    }

    function onDocumentMouseMove( event ) {
        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        //sprite1.position.set(mouse.x, mouse.y, 1 );
        //console.log(document.getElementById('contextmenu').style.left);

        /*if(document.getElementById('contextmenu').style.display==="none") {
            document.getElementById('contextmenu').style.left = event.clientX + "px";
            document.getElementById('contextmenu').style.top = event.clientY + "px";
        }*/

        //console.log(document.getElementById('contextmenu').style.left);
        raytracing(event);

    }

    function onWindowResize() {

        resetWindowSize();
    }

    function resetWindowSize()
    {
        camera_in_use.aspect = window.innerWidth / window.innerHeight;
        camera_in_use.updateProjectionMatrix();
        if(asciibool) {
            ASCIIEffect.setSize(window.innerWidth, window.innerHeight);
        }
        else {
            renderer.setSize(window.innerWidth || 1, window.innerHeight || 1);
            composer.setSize(window.innerWidth || 1, window.innerHeight || 1);
            effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        }
    }

    function onKeyDown(event) {
        var MoveDelta=10;

        switch (event.keyCode) {

            case 79:event.preventDefault();//o
                if(orthobool)
                {
                    orthobool=false;
                    camera_in_use.toPerspective();
                    //camera_in_use=perspec_camera;
                }
                else
                {
                    orthobool=true;
                    camera_in_use.toOrthographic();
                    // camera_in_use=ortho_camera;
                }resetWindowSize();camera_in_use.setZoom(1);controls_in_use.update();camera_in_use.updateMatrixWorld();camera_in_use.updateProjectionMatrix();break;
            case 220: event.preventDefault();//\
                if(asciibool)
                {
                    container.removeChild(ASCIIEffect.domElement);container.appendChild( renderer.domElement );controls_in_use = regcontrols;asciibool=false;VRbool=true;
                }
                else if(stereobool)
                {
                    resetWindowSize();controls_in_use = regcontrols;stereobool=false;VRbool=true;
                }
                else if(VRbool)
                {
                    resetWindowSize();controls_in_use = regcontrols;VRbool=false;
                }
                else
                {
                    if(renderer.vr){
                        WEBVR.getVRDisplay(function (display){renderer.vr.setDevice(display)});
                    }
                    controls_in_use = regcontrols;VRbool=true;
                }
                break;
            case 219: event.preventDefault();//[
                if(asciibool)
                {
                    container.removeChild(ASCIIEffect.domElement);container.appendChild( renderer.domElement );resetWindowSize();controls_in_use = regcontrols;asciibool=false;
                }
                else if(stereobool)
                {
                    container.removeChild(renderer.domElement);container.appendChild( ASCIIEffect.domElement );resetWindowSize();controls_in_use = asciicontrols;stereobool=false;asciibool=true;
                }
                else if (VRbool)
                {
                    container.removeChild(renderer.domElement);container.appendChild( ASCIIEffect.domElement );resetWindowSize();controls_in_use = asciicontrols;VRbool=false;asciibool=true;
                }
                else
                {
                    container.removeChild(renderer.domElement);container.appendChild( ASCIIEffect.domElement );resetWindowSize();controls_in_use = asciicontrols;asciibool=true;
                }
                break;
            case 221: event.preventDefault();//]
                if(asciibool)
                {
                    container.removeChild(ASCIIEffect.domElement);container.appendChild( renderer.domElement );controls_in_use = perspecregcontrols;asciibool=false;stereobool=true;
                }
                else if(stereobool)
                {
                    resetWindowSize();controls_in_use = regcontrols;stereobool=false;
                }
                else if(VRbool)
                {
                    resetWindowSize();controls_in_use = perspecregcontrols;VRbool=false;stereobool=true;
                }
                else
                {
                    controls_in_use = perspecregcontrols;stereobool=true;
                }
                break;
            case 87: event.preventDefault();camera_in_use.translateZ(-MoveDelta);player.translateZ(-MoveDelta);raytracing(event);break;//w
            case 83: event.preventDefault();camera_in_use.translateZ(MoveDelta);player.translateZ(MoveDelta);raytracing(event);break;//s
            case 65: event.preventDefault();camera_in_use.translateX(-MoveDelta);player.translateX(-MoveDelta);raytracing(event);break;//a
            case 68: event.preventDefault();camera_in_use.translateX(MoveDelta);player.translateX(MoveDelta);raytracing(event);break;//d
            case 32: event.preventDefault();camera_in_use.translateY(MoveDelta);player.translateY(MoveDelta);raytracing(event);break;//spacebar
            case 90: event.preventDefault();camera_in_use.translateY(-MoveDelta);player.translateY(-MoveDelta);raytracing(event);break;//z
            case 82: event.preventDefault();CatchARide();break;

        }
        camera_in_use.updateMatrixWorld();
        resetOrbitPoint(controls_in_use,camera_in_use,camera_facing);
        perspec_camera.updateMatrixWorld();
        resetOrbitPoint(perspecregcontrols,perspec_camera,camera_facing);


    }
    //
    function CatchARide()
    {
        var objToAtt=INTERSECTED_OBJECT;

        if(objToAtt)
        {
            if (objToAtt.name.split('_')[0] === "track") {

                attached_camera=true;
                attached_name=objToAtt.name;
                console.log(objToAtt.name)
            }
            else {
                attached_camera=false;
            }
        }
        else
        {
            attached_camera=false;
        }

    }

    function resetOrbitPoint(controls,camera,camera_facing)
    {

        camera.getWorldDirection(camera_facing);
        orbit_point = camera.position.clone().add(camera_facing.clone().setLength(30));//pretty much an arbitrary length above 10
        if (controls !== stereocontrols ) {
            controls.target.set(orbit_point.x, orbit_point.y, orbit_point.z);
        }
    }
    function updateTrackPositions(lineGeo,max_swim_steps) {
        var positions = lineGeo.children[0].geometry.attributes.position.array;
        var parent=lineGeo.geometry.vertices;
        var limit=parent.length;
        var index = 0;
        for ( var i = 0; i<max_swim_steps; i ++ ) {
            if(parent[i]) {
                positions[index++] = parent[i].x;
                positions[index++] = parent[i].y;
                positions[index++] = parent[i].z;
            }
            else
            {
                positions[index++] = parent[limit-1].x;
                positions[index++] = parent[limit-1].y;
                positions[index++] = parent[limit-1].z;
            }
        }
    }

    function SetSceneTime(value)
    {

        var valueToSet=/*document.getElementById('myRange').*/value;

        var TimeToSet= ((parseFloat(valueToSet)/100.)*(ViewerConfig.max_clock_time-ViewerConfig.min_clock_time))+ViewerConfig.min_clock_time;
        SceneClockOffset=TimeToSet;
        SceneClock=TimeToSet;

        //console.log(clock.elapsedTime);
        clock.stop();
        clock.start();
        //console.log(clock.elapsedTime);
        //console.log("SET THIS TIME:");
        //console.log(TimeToSet);

    }
    function updateClockMessage(clock,time_scale) {

        updateProgressBar();
        //console.log("Clock Message:");
        //console.log(clock.getElapsedTime());
        var SceneTime = clock.getElapsedTime() * time_scale + (SceneClockOffset-min_start_time);
        //console.log(SceneTime);

        var timeToShow = (min_start_time + SceneTime);
        if(SceneTime+min_start_time > max_total_time+2*time_scale)
        {
            clock.stop();
            clock.start();
            SceneClockOffset=min_start_time;
        }
        if (timeToShow > (max_total_time)) {
            timeToShow = max_total_time;
        }
        if(timeToShow<ViewerConfig.min_clock_time)
        {
            timeToShow=ViewerConfig.min_clock_time;
        }
        else if( timeToShow>ViewerConfig.max_clock_time )
        {
            timeToShow=ViewerConfig.max_clock_time;
        }

        var errNum = 99999999999;
        if (ViewerConfig.SceneTimeMessage === errNum.toFixed(3)) {
            $("#EventClock").text("NO HITS IN EVENT");
            //ViewerConfig.SceneTimeMessage = "NO TRACKS IN EVENT"
        }
        else {
            SceneClock=timeToShow;
            $("#EventClock").text(timeToShow.toFixed(3) + " ns");
        }

    }
    function animateFCALHits(SceneTime,eventobj) {
        if (eventobj.userData.t > ViewerConfig.max_clock_time ||
            eventobj.userData.t < ViewerConfig.min_clock_time) {
            eventobj.material.visible = false;
            return;
        }//RESPECT THE CLOCK BOUNDS FCALHits
        else {
            if (eventobj.userData.E > ViewerConfig.FCAL_HitEcut && ViewerConfig.FCALHitVis !== "Off")
                eventobj.material.visible = true;
        }

        if (ViewerConfig.FCALHitVis === "Dynamic") {
            if (SceneTime > eventobj.userData.t) {
                eventobj.scale.set(1, 1, eventobj.userData.E * ViewerConfig.FCAL_EScale);
                eventobj.position.z = (655 + (eventobj.userData.E * ViewerConfig.FCAL_EScale / 2) + 15);//(655+((SceneTime/max_total_time)*eventobjs[i].userData.E*ViewerConfig.FCAL_EScale)/2);
                eventobj.geometryNeedsUpdate = true;

            }
            else if (SceneTime < eventobj.userData.t && eventobj.scale.z !== 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.position.z = (655 + 1 + 15);
                eventobj.geometryNeedsUpdate = true;
            }
        }
        else if (ViewerConfig.FCALHitVis === "Off" && eventobj.material.visibile === true) {
            eventobj.material.visibile = false;
        }
        else if (ViewerConfig.FCALHitVis === "Static" && eventobj.scale.z !== eventobj.userData.E * ViewerConfig.FCAL_EScale) {
            eventobj.scale.set(1, 1, eventobj.userData.E * ViewerConfig.FCAL_EScale);
            eventobj.position.z = (655 + (eventobj.userData.E * ViewerConfig.FCAL_EScale / 2) + 15);
            eventobj.geometryNeedsUpdate = true;
        }
    }
    function animateFCALShowers(SceneTime,eventobj) {
        if (eventobj.userData.fTime > ViewerConfig.max_clock_time ||
            eventobj.userData.fTime < ViewerConfig.min_clock_time) {
            eventobj.material.visible = false;
            return;
        }//RESPECT THE CLOCK BOUNDS FCAL Shower
        else {
            if (eventobj.userData.fEnergy > ViewerConfig.FCAL_ShowerEcut && ViewerConfig.FCALShowerVis !== "Off")
                eventobj.material.visible = true;
        }
        if (ViewerConfig.FCALShowerVis === "Dynamic") {
            if (SceneTime > eventobj.userData.fTime) {
                eventobj.scale.set(10, 20, 10);
                eventobj.position.z = eventobj.userData.position[0][2] + 10;
                eventobj.geometryNeedsUpdate = true;

            }
            else if (SceneTime < eventobj.userData.fTime && eventobj.scale.z !== 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.position.z = eventobj.userData.position[0][2] + .5;
                eventobj.geometryNeedsUpdate = true;
            }
        }
        else if (ViewerConfig.FCALShowerVis === "Off" && eventobj.material.visibile === true) {
            eventobj.material.visibile = false;
        }
        else if (ViewerConfig.FCALShowerVis === "Static" && eventobj.scale.z !== 10) {
            eventobj.scale.set(10, 20, 10);
            eventobj.position.z = eventobj.userData.position[0][2] + 5;
            eventobj.geometryNeedsUpdate = true;
        }
    }
    function animateTOFHits(SceneTime) {

        var eventObj = scene.getObjectByName("GluexGeometry");
        if (eventObj) {


            var geoobjs = eventObj.getObjectByName("FTOF");

            if (geoobjs) {
                for (var plane = 0; plane < geoobjs.children.length; plane++) {
                    for (var block = 0; block < geoobjs.children[plane].children.length; block++) {
                        for (var bar = 0; bar < geoobjs.children[plane].children[block].children.length; bar++) {

                            if (ViewerConfig.TOFHitVis === "Dynamic" || ViewerConfig.TOFHitVis === "Static" || ViewerConfig.TOFHitVis === "Off") {

                                var numhits0 = 0;
                                var numhits1 = 0;
                                if(geoobjs.children[plane].children[block].children[bar].userData.HitTimes) {
                                    for (var j = 0; j < geoobjs.children[plane].children[block].children[bar].userData.HitTimes.length; j++) {
                                        if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['time'] > ViewerConfig.max_total_time ||
                                            geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['time'] < ViewerConfig.min_clock_time) {
                                            continue;
                                        }//RESPECT THE CLOCK BOUNDS TOF

                                        if (SceneTime >= geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['time'] || ViewerConfig.TOFHitVis === "Static") {

                                            if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['end'] === 0) {
                                                numhits0++;
                                            }
                                            else if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[j]['end'] === 1) {
                                                numhits1++;
                                            }

                                        }
                                    }
                                }

                                for (var end = 0; end <= 1; end++) {

                                    var numhits = 0;

                                    if (end === 0) {
                                        numhits = numhits0;
                                    }
                                    else {
                                        numhits = numhits1;
                                    }
                                    var colorR = 249./255.;
                                    var colorG = 249./255.;
                                    var colorB = 237./255.;
                                    if (numhits === 0) {
                                        colorR = 249./255.;
                                        colorG = 249./255.;
                                        colorB = 237./255.;

                                    }
                                    else if (numhits === 1) {
                                        colorR = 1;
                                        colorG = 1;
                                        colorB = 0;
                                        //console.log("first hit");
                                    }
                                    else if (numhits === 2) {
                                        colorR = 1;
                                        colorG = .66;
                                        colorB = 0;
                                        //console.log("second hit");
                                    }
                                    else if (numhits === 3) {
                                        colorR = 1;
                                        colorG = 0;
                                        colorB = 0;
                                        //console.log("second hit");
                                    }
                                    else {
                                        colorR = 1;
                                        colorG = 0;
                                        colorB = 0;
                                    }

                                    if (ViewerConfig.TOFHitVis === "Off") {
                                        colorR = 1;
                                        colorG = 1;
                                        colorB = 1;
                                    }

                                    var face_sent1 = -1;
                                    var face_sent2 = -1;

                                    if (end === 1) {
                                        face_sent1 = 2;
                                        face_sent2 = 3;
                                    } else {
                                        face_sent1 = 0;
                                        //face_sent2 = 0;
                                    }

                                    var half_length = false;

                                    var half_tag = geoobjs.children[plane].children[block].children[bar].name.split("_")[2];
                                    if (half_tag === "m21" || half_tag === "m22")
                                        half_length = true;

                                    for (var i = 0; i < geoobjs.children[plane].children[block].children[bar].geometry.faces.length; i++) {

                                        if ((i === face_sent1 || i === face_sent2) && !half_length) {
                                            geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.r = colorR;
                                            geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.g = colorG;
                                            geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.b = colorB;
                                            geoobjs.children[plane].children[block].children[bar].geometry.colorsNeedUpdate = true;


                                        }
                                        else {
                                            var sent = 0;
                                            if (end === 1)
                                                sent = 1;

                                            if (i % 2 === sent || half_length) {
                                                geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.r = colorR;
                                                geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.g = colorG;
                                                geoobjs.children[plane].children[block].children[bar].geometry.faces[i].color.b = colorB;
                                                geoobjs.children[plane].children[block].children[bar].geometry.colorsNeedUpdate = true;
                                            }
                                        }
                                    }
                                }
                            }

                        }

                    }

                }

            }
        }
    }
    function animateBCALHits(SceneTimeIn) {
        var SceneTime=SceneTimeIn;
        var bcalobj = scene.getObjectByName("BCAL", true);
        if (bcalobj) {
            for (var end = 0; end <= 1; end++) {
                var geoobjs = bcalobj.children[end];

                if (geoobjs) {
                    for (var part = 0; part < geoobjs.children.length; part++) {

                        if (geoobjs.children[part].userData.t) {
                            if (geoobjs.children[part].userData.t > ViewerConfig.max_clock_time ||
                                geoobjs.children[part].userData.t < ViewerConfig.min_clock_time) {

                                if (geoobjs.children[part].name.split("_")[2] === "l4") {
                                    geoobjs.children[part].material.color.setRGB(179. / 255., 165. / 255., 128. / 255.);
                                }
                                else if (geoobjs.children[part].name.split("_")[2] === "l3") {
                                    geoobjs.children[part].material.color.setRGB(222. / 255., 210. / 255., 158. / 255.);
                                }
                                else if (geoobjs.children[part].name.split("_")[2] === "l2") {
                                    geoobjs.children[part].material.color.setRGB(225. / 255., 221. / 255., 181. / 255.);
                                }
                                else if (geoobjs.children[part].name.split("_")[2] === "l1") {
                                    geoobjs.children[part].material.color.setRGB(221. / 255., 209. / 255., 190. / 255.);
                                }

                                continue;
                            }//RESPECT THE CLOCK BOUNDS

                            if (ViewerConfig.BCALHitVis === "Dynamic") {
                                if (SceneTime > geoobjs.children[part].userData.t) {
                                    geoobjs.children[part].material.color.setRGB(255. / 255., 0. / 255., 0. / 255.);
                                }
                                else if (SceneTime < geoobjs.children[part].userData.t || firstShowing) {
                                    if (geoobjs.children[part].name.split("_")[2] === "l4") {
                                        geoobjs.children[part].material.color.setRGB(179. / 255., 165. / 255., 128. / 255.);
                                    }
                                    else if (geoobjs.children[part].name.split("_")[2] === "l3") {
                                        geoobjs.children[part].material.color.setRGB(222. / 255., 210. / 255., 158. / 255.);
                                    }
                                    else if (geoobjs.children[part].name.split("_")[2] === "l2") {
                                        geoobjs.children[part].material.color.setRGB(225. / 255., 221. / 255., 181. / 255.);
                                    }
                                    else if (geoobjs.children[part].name.split("_")[2] === "l1") {
                                        geoobjs.children[part].material.color.setRGB(221. / 255., 209. / 255., 190. / 255.);
                                    }
                                }
                            }
                            else if (ViewerConfig.BCALHitVis === "Off") {
                                if (geoobjs.children[part].name.split("_")[2] === "l4") {
                                    geoobjs.children[part].material.color.setRGB(179. / 255., 165. / 255., 128. / 255.);
                                }
                                else if (geoobjs.children[part].name.split("_")[2] === "l3") {
                                    geoobjs.children[part].material.color.setRGB(222. / 255., 210. / 255., 158. / 255.);
                                }
                                else if (geoobjs.children[part].name.split("_")[2] === "l2") {
                                    geoobjs.children[part].material.color.setRGB(225. / 255., 221. / 255., 181. / 255.);
                                }
                                else if (geoobjs.children[part].name.split("_")[2] === "l1") {
                                    geoobjs.children[part].material.color.setRGB(221. / 255., 209. / 255., 190. / 255.);
                                }
                            }
                            else if (ViewerConfig.BCALHitVis === "Static") {
                                if (geoobjs.children[part].userData.t) {
                                    geoobjs.children[part].material.color.setRGB(255. / 255., 0. / 255., 0. / 255.);
                                }

                            }
                        }
                        geoobjs.colorsNeedUpdate = true;
                    }
                }
            }
        }
    }
    function animateTOFPoints(SceneTime,eventobj) {
        if (eventobj.userData.t > ViewerConfig.max_clock_time ||
            eventobj.userData.t < ViewerConfig.min_clock_time) {
            eventobj.material.visible = false;
            return;
        }//RESPECT THE CLOCK BOUNDS TOF POINTS
        else {
            if (ViewerConfig.TOFPointVis !== "Off")
                eventobj.material.visible = true;
        }
        if (ViewerConfig.TOFPointVis === "Dynamic") {
            if (SceneTime > eventobj.userData.t && eventobj.material.color.b === 1) {
                eventobj.scale.set(3, 3, 3);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 1;
                eventobj.material.color.g = 0;
                eventobj.material.color.b = 0;
                eventobj.colorsNeedUpdate = true;
            }
            else if (SceneTime < eventobj.userData.t && eventobj.material.color.r === 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 0;
                eventobj.material.color.g = 0;
                eventobj.material.color.b = 1;
                eventobj.colorsNeedUpdate = true;
            }
        }
        else if (ViewerConfig.TOFPointVis === "Off" && eventobj.material.visibile === true) {
            eventobj.material.visible = false;
        }
        else if (ViewerConfig.TOFPointVis === "Static" && eventobj.material.color.r === 1) {
            eventobj.scale.set(1, 1, 1);
            eventobj.geometryNeedsUpdate = true;
            eventobj.material.color.r = 0;
            eventobj.material.color.g = 0;
            eventobj.material.color.b = 1;
            eventobj.colorsNeedUpdate = true;
        }
    }
    function animateSCHits(SceneTime) {
        var scobj=scene.getObjectByName("SC");
        if(scobj) {
            var eventobjs =scobj.children[0].children;
            for (var i = 0; i < eventobjs.length; i++) {
                if (eventobjs[i].userData.t) {
                    if (eventobjs[i].userData.t > ViewerConfig.max_clock_time ||
                        eventobjs[i].userData.t < ViewerConfig.min_clock_time) {
                        eventobjs[i].material.color.setRGB(1, 1, 1);
                        continue;
                    }//RESPECT THE CLOCK BOUNDS TOF POINTS

                    if (ViewerConfig.SCHitVis === "Dynamic") {
                        if (SceneTime > eventobjs[i].userData.t) {
                            eventobjs[i].material.color.setRGB(255. / 255., 141. / 255., 66. / 255.);
                        }
                        else if (SceneTime < eventobjs[i].userData.t) {
                            eventobjs[i].material.color.setRGB(1, 1, 1);
                        }
                    }
                    else if (ViewerConfig.SCHitVis === "Off") {
                        eventobjs[i].material.color.setRGB(1, 1, 1);
                    }
                    else if (ViewerConfig.SCHitVis === "Static") {
                        eventobjs[i].material.color.setRGB(255. / 255., 141. / 255., 66. / 255.);
                    }
                }
            }
        }
    }
    function animateCDCHits(SceneTime) {

        var cdcobj = scene.getObjectByName("CDC");
        if (cdcobj) {


            var eventobjs = cdcobj.children;

            for (var i = 0; i < eventobjs.length; i++) {
                if (eventobjs[i].userData.t) {
                    if (eventobjs[i].userData.t > ViewerConfig.max_clock_time ||
                        eventobjs[i].userData.t < ViewerConfig.min_clock_time) {
                        eventobjs[i].material.visible = false;
                        //continue;
                    }//RESPECT THE CLOCK BOUNDS TOF POINTS
                    else {
                        if (ViewerConfig.CDCHitVis !== "Off")
                            eventobjs[i].material.visible = true;
                    }
                    if (ViewerConfig.CDCHitVis === "Dynamic") {
                        if (SceneTime > eventobjs[i].userData.t && eventobjs[i].material.visible === false) {
                            eventobjs[i].material.visible = true;
                        }
                        else if (SceneTime < eventobjs[i].userData.t && eventobjs[i].material.visible === true) {
                            eventobjs[i].material.visible = false;
                        }
                    }
                    else if (ViewerConfig.CDCHitVis === "Off" && eventobjs[i].material.visible === true) {
                        eventobjs[i].material.visible = false;
                    }
                    else if (ViewerConfig.CDCHitVis === "Static" && eventobjs[i].material.visible === false) {
                        eventobjs[i].material.visible = true;
                    }
                }
            }
        }
    }
    function animateFDCPseudos(SceneTime,eventobj) {

        if (eventobj.userData.time > ViewerConfig.max_clock_time ||
            eventobj.userData.time < ViewerConfig.min_clock_time) {
            eventobj.material.visible = false;
            return;
        }//RESPECT THE CLOCK BOUNDS TOF POINTS
        else {
            if (ViewerConfig.FDCPseudoVis !== "Off")
                eventobj.material.visible = true;
        }
        if (ViewerConfig.FDCPseudoVis === "Dynamic") {
            if (SceneTime > eventobj.userData.time && eventobj.material.color.b === 1) {
                eventobj.scale.set(2, 2, 2);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 1;
                eventobj.material.color.g = 0;
                eventobj.material.color.b = 0;
                eventobj.colorsNeedUpdate = true;
            }
            else if (SceneTime < eventobj.userData.time && eventobj.material.color.r === 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 0;
                eventobj.material.color.g = 0;
                eventobj.material.color.b = 1;
                eventobj.colorsNeedUpdate = true;
            }
        }
        else if (ViewerConfig.FDCPseudoVis === "Off" && eventobj.material.visible === true) {
            eventobj.material.visible = false;
        }
        else if (ViewerConfig.FDCPseudoVis === "Static" && eventobj.material.color.r === 1) {
            eventobj.scale.set(1, 1, 1);
            eventobj.geometryNeedsUpdate = true;
            eventobj.material.color.r = 0;
            eventobj.material.color.g = 0;
            eventobj.material.color.b = 1;
            eventobj.colorsNeedUpdate = true;
        }
    }
    function animateBCALPoints(SceneTime,eventobj) {
        if (eventobj.userData.t > ViewerConfig.max_clock_time ||
            eventobj.userData.t < ViewerConfig.min_clock_time) {
            eventobj.material.visible = false;
            return;
        }//RESPECT THE CLOCK BOUNDS TOF POINTS
        else {
            if (ViewerConfig.BCALPointVis !== "Off")
                eventobj.material.visible = true;
        }
        if (ViewerConfig.BCALPointVis === "Dynamic") {
            if (SceneTime > eventobj.userData.t && eventobj.material.color.b === 255. / 255.) {
                eventobj.scale.set(2, 2, 2);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 255. / 255.;
                eventobj.material.color.g = 157. / 255.;
                eventobj.material.color.b = 30. / 255.;
                eventobj.colorsNeedUpdate = true;
            }
            else if (SceneTime < eventobj.userData.t && eventobj.material.color.r === 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.geometryNeedsUpdate = true;
                eventobj.material.color.r = 104. / 255.;
                eventobj.material.color.g = 214. / 255.;
                eventobj.material.color.b = 255. / 255.;
                eventobj.colorsNeedUpdate = true;
            }
        }
        else if (ViewerConfig.BCALPointVis === "Off" && eventobj.material.visible === true) {
            eventobj.material.visible = false;
        }
        else if (ViewerConfig.BCALPointVis === "Static" && eventobj.material.color.r === 1) {
            eventobj.scale.set(1, 1, 1);
            eventobj.geometryNeedsUpdate = true;
            eventobj.material.color.r = 114. / 255.;
            eventobj.material.color.g = 255. / 255.;
            eventobj.material.color.b = 191. / 255.;
            eventobj.colorsNeedUpdate = true;
        }
    }
    function animateBCALShowers(SceneTime,eventobj) {

        if (eventobj.userData.t > ViewerConfig.max_clock_time ||
            eventobj.userData.t < ViewerConfig.min_clock_time) {
            eventobj.material.visible = false;
            return;
        }//RESPECT THE CLOCK BOUNDS BCAL Shower
        else {
            if (eventobj.userData.E > ViewerConfig.BCAL_ShowerEcut && ViewerConfig.BCALShowerVis !== "Off")
                eventobj.material.visible = true;
        }
        if (ViewerConfig.BCALShowerVis === "Dynamic") {
            if (SceneTime > eventobj.userData.t) {
                var EScale = 5 + 10 * eventobj.userData.E;
                eventobj.scale.set(EScale, 2 * EScale, EScale);
                eventobj.position.z = eventobj.userData.position[0][2] + EScale;
                eventobj.geometryNeedsUpdate = true;

            }
            else if (SceneTime < eventobj.userData.t && eventobj.scale.z !== 1) {
                eventobj.scale.set(1, 1, 1);
                eventobj.position.z = eventobj.userData.position[0][2] + .5;
                eventobj.geometryNeedsUpdate = true;
            }
        }
        else if (ViewerConfig.BCALShowerVis === "Off" && eventobj.material.visibile === true) {
            eventobj.material.visible = false;
        }
        else if (ViewerConfig.BCALShowerVis === "Static" && eventobj.scale.z === 1) {
            var EScale = 5 + 10 * eventobj.userData.E;
            eventobj.scale.set(EScale, 2 * EScale, EScale);
            eventobj.position.z = eventobj.userData.position[0][2] + EScale;
            eventobj.geometryNeedsUpdate = true;
        }
    }
    function animateTrackLines(SceneTime,eventobj,max_swim_steps) {


        var thisGeo = eventobj.children[0].geometry;
        var track_start = (eventobj.userData.start_time);//-min_start_time;
        var draw_count = 0;

        for (; draw_count < max_swim_steps; draw_count++) {
            /*if(SceneTime>ViewerConfig.max_clock_time)
                    {
                        break;
                    }*/
            if (draw_count >= eventobj.userData.steps.length) {
                break;
            }
            if ((((eventobj.userData.steps[draw_count])[3]) + track_start) > SceneTime) {
                break;
            }
        }

        if(attached_camera && attached_name === eventobj.name && SceneTime>=track_start)
        {
            var facing_index=draw_count+1;
            if(draw_count >= eventobj.userData.steps.length ) {
                draw_count = eventobj.userData.steps.length - 1;
                facing_index=draw_count-1;
            }

            //INTERPOLATE
            var delta_x=eventobj.userData.steps[facing_index-1][0]-eventobj.userData.steps[draw_count-1][0];
            var delta_y=eventobj.userData.steps[facing_index-1][1]-eventobj.userData.steps[draw_count-1][1];
            var delta_z=eventobj.userData.steps[facing_index-1][2]-eventobj.userData.steps[draw_count-1][2];
            var delta_t=eventobj.userData.steps[facing_index-1][3]-eventobj.userData.steps[draw_count-1][3];
            var interpoint_t=(SceneTime-(eventobj.userData.steps[draw_count-1][3]+track_start));
            if(draw_count === eventobj.userData.steps.length - 1 )
            {
                interpoint_t=0;
            }
            /*console.log(eventobj.userData.steps[draw_count-1][3]+track_start);
            console.log("--->"+(eventobj.userData.steps[facing_index-1][3]+track_start));
            console.log(delta_x+" with: "+delta_t);
            console.log("inter point time: "+ interpoint_t );*/

            var x_pos=eventobj.userData.steps[draw_count-1][0]+(interpoint_t*(delta_x/delta_t));
            var y_pos=eventobj.userData.steps[draw_count-1][1]+(interpoint_t*(delta_y/delta_t));
            var z_pos=eventobj.userData.steps[draw_count-1][2]+(interpoint_t*(delta_z/delta_t));

           /* console.log("x: "+eventobj.userData.steps[draw_count-1][0]+" v "+x_pos+" v "+eventobj.userData.steps[facing_index-1][0]);
            console.log("y: "+eventobj.userData.steps[draw_count-1][1]+" v "+y_pos+" v "+eventobj.userData.steps[facing_index-1][1]);
            console.log("z: "+eventobj.userData.steps[draw_count-1][2]+" v "+z_pos+" v "+eventobj.userData.steps[facing_index-1][2]);
           */
           // console.log(eventobj.userData.steps[draw_count-1][3]+track_start);
           // console.log("--->"+(eventobj.userData.steps[facing_index-1][3]+track_start));


            snapTo(x_pos,y_pos,z_pos,eventobj.userData.steps[facing_index-1][0],eventobj.userData.steps[facing_index-1][1],eventobj.userData.steps[facing_index-1][2]);
            //console.log(eventobj.userData.steps[draw_count][0]);
            //snapTo(eventobj.userData.steps[draw_count-1][0],eventobj.userData.steps[draw_count-1][1],eventobj.userData.steps[draw_count-1][2],eventobj.userData.steps[facing_index-1][0],eventobj.userData.steps[facing_index-1][1],eventobj.userData.steps[facing_index-1][2]);

        }

        if (thisGeo) {
            thisGeo.drawRange.start = 0;

            thisGeo.drawRange.count = draw_count;
            //ViewerConfig.SceneTimeMessage=timeToShow.toFixed(3);


            if ((ViewerConfig.positive_track_line === 'Off' && eventobj.userData.charge === 1) ||
                (ViewerConfig.negative_track_line === 'Off' && eventobj.userData.charge === -1) ||
                (ViewerConfig.neutral_track_line === 'Off' && eventobj.userData.charge === 0)) {
                thisGeo.drawRange.count = 0;
                //ViewerConfig.SceneTimeMessage = max_total_time.toFixed(3);

            }
            else if ((ViewerConfig.positive_track_line === 'Static' && eventobj.userData.charge === 1) ||
                (ViewerConfig.negative_track_line === 'Static' && eventobj.userData.charge === -1) ||
                (ViewerConfig.neutral_track_line === 'Static' && eventobj.userData.charge === 0)) {
                thisGeo.drawRange.count = max_swim_steps;
                //ViewerConfig.SceneTimeMessage = max_total_time.toFixed(3);

            }

        }


    }
    function animateFDCHits(SceneTime,eventobj) {

        if (eventobj.userData.t > ViewerConfig.max_clock_time ||
            eventobj.userData.t < ViewerConfig.min_clock_time) {
            eventobj.material.visible = false;
            return;
        }//RESPECT THE CLOCK BOUNDS FDCHit
        else {
            if (ViewerConfig.FDCHitVis !== "Off") {
                eventobj.material.visible = true;
            }
        }

        if (ViewerConfig.FDCHitVis === "Dynamic") {
            if (SceneTime > eventobj.userData.t) {
                if ((ViewerConfig.FDCHitTypeVis === "Cathodes" && eventobj.userData.type !== 0) || (ViewerConfig.FDCHitTypeVis === "Anodes" && eventobj.userData.type === 0) || ViewerConfig.FDCHitTypeVis === "Both") {
                    eventobj.material.visible = true;
                }
                else {
                    eventobj.material.visible = false;
                }
            }
            else if (SceneTime < eventobj.userData.t && eventobj.material.visible !== false) {
                eventobj.material.visible = false;
            }
        }
        else if (ViewerConfig.FDCHitVis === "Off" && eventobj.material.visible === true) {
            eventobj.material.visible = false;
        }
        else if (ViewerConfig.FDCHitVis === "Static") {
            if ((ViewerConfig.FDCHitTypeVis === "Cathodes" && eventobj.userData.type !== 0) || (ViewerConfig.FDCHitTypeVis === "Anodes" && eventobj.userData.type === 0) || ViewerConfig.FDCHitTypeVis === "Both") {
                eventobj.material.visible = true;
            }
            else {
                eventobj.material.visible = false;
            }

        }
    }
    function UpdateAnimationTriggers(eventobjs) {
        max_swim_steps=0;
        max_swim_time=0;
        min_start_time=99999999999;
        max_total_time=-9999999999;
        for (var i = 0; i < eventobjs.length; i++)
        {
            if (eventobjs[i].name.split('_')[0] === "track") {
                if(eventobjs[i].userData.TrackChiSq_NDF>ViewerConfig.TrackingChiSq_NDF_cut
                    && ViewerConfig.TrackingChiSq_NDF_cut !==0)
                {continue;}

                var last_step=(eventobjs[i].userData.steps.length)-1;
                if((eventobjs[i].userData.steps[last_step][3]) > max_swim_time)
                {
                    max_swim_time=(eventobjs[i].userData.steps[last_step][3]);
                }
                if(eventobjs[i].userData.start_time < min_start_time)
                {
                    min_start_time=eventobjs[i].userData.start_time;
                }
                if(eventobjs[i].geometry.vertices.length > max_swim_steps)
                {
                    max_swim_steps=eventobjs[i].geometry.vertices.length;
                }
                if((eventobjs[i].userData.steps[last_step][3])+eventobjs[i].userData.start_time > max_total_time)
                {
                    max_total_time=(eventobjs[i].userData.steps[last_step][3])+eventobjs[i].userData.start_time
                }
            }
            //two tof point classes (in track time...or out) so don't let them contribute to min/max time
            if(ViewerConfig.TOFPointVis !== "Off" && ViewerConfig.TOFPointVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "TOFPoint") {
                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }

            if(ViewerConfig.BCALPointVis !== "Off" && ViewerConfig.BCALPointVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "BCALPoint") {
                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }

            if(ViewerConfig.FCALHitVis !== "Off" && ViewerConfig.FCALHitVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FCALHit") {
                    if(eventobjs[i].userData.E<ViewerConfig.FCAL_HitEcut)
                    {continue;}

                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }


            if(ViewerConfig.FDCHitVis !== "Off" && ViewerConfig.FDCHitVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FDCHit") {

                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }
            if(ViewerConfig.FDCPseudoVis !== "Off" && ViewerConfig.FDCPseudoVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FDCPseudo") {

                    if (eventobjs[i].userData.time < min_start_time) {
                        min_start_time = eventobjs[i].userData.time;
                    }
                    if (eventobjs[i].userData.time > max_total_time) {
                        max_total_time = eventobjs[i].userData.time;
                    }
                }
            }
            if(ViewerConfig.FCALShowerVis !== "Off" && ViewerConfig.FCALShowerVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "FCALShower") {
                    if (eventobjs[i].userData.fTime < min_start_time) {
                        min_start_time = eventobjs[i].userData.fTime;
                    }
                    if (eventobjs[i].userData.fTime > max_total_time) {
                        max_total_time = eventobjs[i].userData.fTime;
                    }
                }
            }
            if(ViewerConfig.BCALShowerVis !== "Off" && ViewerConfig.BCALShowerVis !=="Static" ) {
                if (eventobjs[i].name.split('_')[0] === "BCALShower") {
                    if (eventobjs[i].userData.t < min_start_time) {
                        min_start_time = eventobjs[i].userData.t;
                    }
                    if (eventobjs[i].userData.t > max_total_time) {
                        max_total_time = eventobjs[i].userData.t;
                    }
                }
            }
        }
        if(ViewerConfig.BCALHitVis !== "Off" && ViewerConfig.BCALHitVis !=="Static" ) {

            var geoobjs = scene.getObjectByName("BCAL", true);

            //LOOP OVER BCAL AND MAKE THE CHECKS
            if (geoobjs) {
                for (var part = 0; part < geoobjs.children.length; part++) {


                    if (geoobjs.children[part].t < min_start_time) {
                        min_start_time = geoobjs.children[part].t;
                    }
                    if (geoobjs.children[part].t > max_total_time) {
                        max_total_time = geoobjs.children[part].t;
                    }
                }
            }
        }
        if(ViewerConfig.TOFHitVis !== "Off" && ViewerConfig.TOFHitVis !=="Static" ) {

            var geoobjs=scene.getObjectByName("FTOF",true);
            if(geoobjs) {
                for (var plane = 0; plane < geoobjs.children.length; plane++) {
                    for (var block = 0; block < geoobjs.children[plane].children.length; block++) {
                        for (var bar = 0; bar < geoobjs.children[plane].children[block].children.length; bar++) {
                            if(geoobjs.children[plane].children[block].children[bar].userData.HitTimes) {
                                for (var hit = 0; hit < geoobjs.children[plane].children[block].children[bar].userData.HitTimes.length; hit++) {

                                    if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'] < min_start_time) {
                                        min_start_time = geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'];
                                    }
                                    if (geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'] > max_total_time) {
                                        max_total_time = geoobjs.children[plane].children[block].children[bar].userData.HitTimes[hit]['time'];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if(ViewerConfig.CDCHitVis !== "Off" && ViewerConfig.CDCHitVis !=="Static" ) {


            var cdcobj=scene.getObjectByName("CDC");
            if(cdcobj) {
                var eventobjs = cdcobj.children;

                for (var i = 0; i < eventobjs.length; i++) {

                    if (eventobjs[i].userData.t) {

                        if (eventobjs[i].userData.t < min_start_time) {
                            min_start_time = eventobjs[i].userData.t;
                        }
                        if (eventobjs[i].userData.t > max_total_time) {
                            max_total_time = eventobjs[i].userData.t;
                        }
                    }

                }
            }
        }
        if(ViewerConfig.SCHitVis !== "Off" && ViewerConfig.SCHitVis !=="Static" ) {

            var scobj=scene.getObjectByName("SC");
            if(scobj) {
                var eventobjs = scobj.children[0].children;

                for (var i = 0; i < eventobjs.length; i++) {

                    if (eventobjs[i].userData.t) {

                        if (eventobjs[i].userData.t < min_start_time) {
                            min_start_time = eventobjs[i].userData.t;
                        }
                        if (eventobjs[i].userData.t > max_total_time) {
                            max_total_time = eventobjs[i].userData.t;
                        }
                    }

                }
            }
        }

        //document.getElementById('myRange').min=ViewerConfig.min_clock_time;
        //document.getElementById('myRange').max=ViewerConfig.max_clock_time;

        if(min_start_time<ViewerConfig.min_clock_time)
        {
            min_start_time=ViewerConfig.min_clock_time;
        }
        if(max_total_time>ViewerConfig.max_clock_time)
        {
            max_total_time=ViewerConfig.max_clock_time;
        }


    }

    function doAnimation()
    {
        var time_scale=ViewerConfig.time_scale;
        updateClockMessage(clock,time_scale);

        var SceneTime=SceneClock;

        var eventObj = scene.getObjectByName("GluexEvent");



        if( eventObj ) {
            var eventobjs = eventObj.children;

            if (ViewerConfig.TimingsNeedsUpdate === true) {
                UpdateAnimationTriggers(eventobjs);
                ViewerConfig.TimingsNeedsUpdate = false;
            }

            if (SceneTime > max_total_time - min_start_time) {
                //RealTime=SceneTime;
                SceneTime = max_total_time - min_start_time;
            }

            for (var i = 0; i < eventobjs.length; i++) {
                var category_name=eventobjs[i].name.split('_')[0];
                if ( category_name === "track") {
                    animateTrackLines(SceneTime, eventobjs[i], max_swim_steps);
                }
                else if ( category_name === "BCALPoint") {
                    animateBCALPoints(SceneTime, eventobjs[i]);
                }
                else if ( category_name === "BCALShower") {
                    animateBCALShowers(SceneTime, eventobjs[i]);
                }
                else if ( category_name === "FDCHit") {
                    animateFDCHits(SceneTime, eventobjs[i]);
                }
                else if ( category_name === "FDCPseudo") {
                    animateFDCPseudos(SceneTime, eventobjs[i]);
                }
                else if ( category_name === "TOFPoint") {
                    animateTOFPoints(SceneTime, eventobjs[i]);
                }
                else if ( category_name === "FCALHit") {
                    animateFCALHits(SceneTime, eventobjs[i]);
                }
                else if ( category_name === "FCALShower") {
                    animateFCALShowers(SceneTime, eventobjs[i]);
                }
            }

            animateSCHits(SceneTime);
            animateCDCHits(SceneTime);
            animateTOFHits(SceneTime);
            animateBCALHits(SceneTime);

            if (firstShowing) {
                firstShowing = false;

                // required after the first render
                for (var i = 0; i < eventobjs.length; i++) {
                    if (eventobjs[i].name.split('_')[0] === "track") {
                        var thisGeo = eventobjs[i].children[0].geometry;

                        updateTrackPositions(eventobjs[i], max_swim_steps);
                        thisGeo.attributes.position.needsUpdate = true;
                    }
                }

            }
        }
    }
    function animate() {

        requestAnimationFrame( animate ); //may need a vr bool for rift.....

        if(controls_in_use === stereocontrols)
            controls_in_use.update();

        if(!isPlaying)
        {
            render();
            return;
        }

        doAnimation();

        render();

    }


    function addSelectedObject(object) {
        selectedObjects = [];
        selectedObjects.push(object);
    }

    function updateObjectInfoPane(message)
    {
        var ObjectDiv = document.getElementById('ObjectInfo');
        ObjectDiv.style.width=(canvas1.getContext("2d").measureText(message).width+100).toString()+"px";
        ObjectDiv.style.color= getContrast50(ViewerConfig.bkg_color);
        ObjectDiv.innerHTML=message;

    }
    function getContrast50(hexcolor){
        return (parseInt(hexcolor, 16) > 0xffffff/2) ? 'black':'white';
    }

    function DumpObjectUserData(object) {

        if(!object)
            return;

        var message = "";
        var objSplit = object.name.split("_");
        var objType = objSplit[0];


        if (objType === "CDCstraw") {
            message = "CDC Straw" + "\r\n" + "Ring: " + objSplit[1] + "\r\n" + "Straw: " + objSplit[2] + "\r\n";
        }
        else if (objType === "SCsector") {
            message = "SC Sector " + objSplit[1] + "\r\n";
        }
        else if (objType === "BCAL") {
            message = "BCAL Hit" + "\r\n" + "Module: " + objSplit[1].substring(1) + "\r\n" + "Layer: " + objSplit[2].substring(1) + "\r\n" + "Sector: " + objSplit[3].substring(1) + "\r\n" + "End: " + objSplit[4].substring(1) + "\r\n";
        }
        else if (objType === "TOFBar") {
            message = "TOF Hit" + "\r\n" + "Plane: " + objSplit[1] + "\r\n" + "Bar: " + objSplit[2] + "\r\n";
        }
        else {
            message = objSplit[1] + "\r\n";
        }

        var userDataList = Object.keys(object.userData);
        var total_data = userDataList.length;

        if (objType === "track") {
            total_data--;
            total_data--;
            total_data--;
        }

        for (var i = 0; i < total_data; i++) {
            // message += ",";

            if(userDataList[i] === "HitTimes")
            {
                continue;
            }
            message += userDataList[i] + ": ";


            if(userDataList[i] === "position")
            {
                var positionvec = object.userData[userDataList[i]][0];
                message += "["+parseFloat(positionvec[0]).toFixed(3)+","+parseFloat(positionvec[1]).toFixed(3)+","+parseFloat(positionvec[2]).toFixed(3)+"]";
            }
            else if(object.userData[userDataList[i]] instanceof Array) {
                message += "[";
                for(var j=0;j<object.userData[userDataList[i]].length;j++)
                {
                    message += object.userData[userDataList[i]][j].toString().substring(0, 7)+", ";
                }
                message = message.substring(0,message.length-2);
                message += "]";
            }
            else {
                message += object.userData[userDataList[i]].toString().substring(0, 7);
            }
            message += "\r\n"
        }

        //console.log(message);
        updateObjectInfoPane(message);
        return message;
    }



    function raytracing(event)
    {
        var vector = new THREE.Vector3();
        var dir = new THREE.Vector3();
        if ( orthobool ) {

            vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, - 1 ); // z = - 1 important!

            vector.unproject( camera_in_use );

            dir.set( 0, 0, - 1 ).transformDirection( camera_in_use.matrixWorld );

            raycaster.set( vector, dir );

        } else {

            vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 ); // z = 0.5 important!

            vector.unproject( camera_in_use );

            raycaster.set( camera_in_use.position, vector.sub( camera_in_use.position ).normalize());

        }

        //raycaster.setFromCamera(mouse, camera_in_use);
        var intersects = raycaster.intersectObjects([scene], true/*event.children*/);

        var valid_intersect = null;
        var searchdepth = 0;
        outlinePass.selectedObjects = [];

        for (; searchdepth < intersects.length; searchdepth++) {
            var skewered_object = intersects[searchdepth].object;

            if (skewered_object.name.substring(0, 5) === "track")//filter for track points
            {
                if (skewered_object.name.substring(0, 6) !== "trackl") {
                    skewered_object = skewered_object.children[0];
                }
                if (skewered_object.geometry.drawRange.count !== 0) {
                    valid_intersect = skewered_object.parent;
                    break;
                }
            }
            else {
                if (Object.keys(skewered_object.userData).length !== 0 && skewered_object.material.visible) {

                    valid_intersect = skewered_object;
                    break;

                }
            }


        }

        if(!ObjectLock) {
            if (valid_intersect) {
                DisplayContextMenu(valid_intersect);
                DumpObjectUserData(valid_intersect);
                addSelectedObject(valid_intersect);
                outlinePass.selectedObjects = selectedObjects;

            }
            else {

                INTERSECTED_OBJECT = null;
                DisplayContextMenu(INTERSECTED_OBJECT);
                updateObjectInfoPane("");

            }
        }
        else
        {
            //DisplayContextMenu(INTERSECTED_OBJECT);
            DumpObjectUserData(INTERSECTED_OBJECT);
            addSelectedObject(INTERSECTED_OBJECT);
            outlinePass.selectedObjects = selectedObjects;
        }

        return valid_intersect;
    }
    function ChangeTrackHypoTo(object, Hypoidto)
    {
        //alert(idfrom+"---->"+Hypoidto);
        var found_index=-1;
        for(var i = 0;i < object.userData.track_hypos.length;i++)
        {
            if(object.userData.track_hypos[i].id === Hypoidto)
            {
                found_index=i;
            }
        }
        console.log(object);

        recursiveRemove(object);

        object.userData.TrackChiSq_NDF=object.userData.track_hypos[found_index].TrackChiSq_NDF;
        object.userData.charge=object.userData.track_hypos[found_index].charge;
        object.userData.current_hypo=object.userData.track_hypos[found_index].id;
        object.userData.mass=object.userData.track_hypos[found_index].mass;
        object.userData.momentum=object.userData.track_hypos[found_index].momentum;
        object.userData.position=object.userData.track_hypos[found_index].position;
        object.userData.start_time=object.userData.track_hypos[found_index].start_time;
        object.userData.steps=object.userData.track_hypos[found_index].points;
        object.name="track_"+object.userData.track_hypos[found_index].id;
        object.geometry.name=object.userData.track_hypos[found_index].id;

        var geometry = new THREE.Geometry();
        geometry.name = object.userData.track_hypos[found_index].id;
        object.userData.track_hypos[found_index].points.forEach(function (point) {
            var vertex = new THREE.Vector3();
            vertex.x = point[0];
            vertex.y = point[1];
            vertex.z = point[2];

            //setRGB(track_color.r,track_color.g,track_color.b);
            geometry.vertices.push(vertex);
        });

        var trackcolor = new THREE.Color;

        if(object.userData.charge === 1)
        {
            trackcolor=ViewerConfig.positive_track_color;
        }
        else if(object.userData.charge === -1)
        {
            trackcolor=ViewerConfig.negative_track_color;
        }
        if(object.userData.charge === 0)
        {
            trackcolor=ViewerConfig.neutral_track_color;
        }


        var linematerial = new THREE.LineBasicMaterial({color:new THREE.Color(trackcolor[0]/255.,trackcolor[1]/255.,trackcolor[2]/255.)  , linewidth: 2});
        linematerial.side = THREE.DoubleSide;
        var lineBufferGeo = new THREE.BufferGeometry().fromGeometry(geometry);
        lineBufferGeo.drawRange.count = 0;
        var positions = new Float32Array(geometry.vertices.length * 3); // 3 vertices per point
        lineBufferGeo.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        var trackLineMesh = new THREE.Line(lineBufferGeo, linematerial);
        trackLineMesh.frustumCulled = false;
        trackLineMesh.name = "trackline_track_" + geometry.name;

        object.add(trackLineMesh);



        object.geometry=geometry;

        object.material.color.setRGB(trackcolor[0]/255.,trackcolor[1]/255.,trackcolor[2]/255.);
        object.geometry.colorsNeedUpdate = true;

        object.colorsNeedUpdate=true;
        object.geometryNeedsUpdate=true;
        console.log(object);
        //UpdateAnimationTriggers(scene.getObjectByName('GluexEvent').children);

        firstShowing=true;
      //  doAnimation();
        //if(!isPlaying)
        //    render();
    }
    function render() {

        if(asciibool)
        {
            ASCIIEffect.render( scene, camera_in_use );
        }
        else if(stereobool)
        {
            StereoEffect.render( scene, perspec_camera );
        }
        else if( VRbool)
        {
            console.log(perspec_camera.position.z);
            renderer.vr.enable=true;
            renderer.render(scene,perspec_camera);
           // OculusEffect.render(scene, camera_in_use);
        }
        else
        {
            //renderer.render(scene,camera);
            composer.render(scene,camera_in_use);
        }

        //stats.update();

    }

    function cleanGeometry(scene, gluexGeometry) {
        if (scene && gluexGeometry) {
           recursiveRemove(gluexGeometry.getObjectByName("CDC", true));
            scene.remove(gluexGeometry.getObjectByName("CDC", true));
            recursiveRemove(gluexGeometry.getObjectByName("BCAL_details", true));
            scene.remove(gluexGeometry.getObjectByName("BCAL_details", true));
            recursiveRemove(gluexGeometry.getObjectByName("BCAL_details2", true));
            scene.remove(gluexGeometry.getObjectByName("BCAL_details2", true));

            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane0_FTOB", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane0_FTOB", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane0_FTOZ", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane0_FTOZ", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane0_FTOS", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane0_FTOS", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane0_FTON", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane0_FTON", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane0_FTOY", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane0_FTOY", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane0_FTOT", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane0_FTOT", true));

            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane1_FTOB", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane1_FTOB", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane1_FTOZ", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane1_FTOZ", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane1_FTOS", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane1_FTOS", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane1_FTON", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane1_FTON", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane1_FTOY", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane1_FTOY", true));
            recursiveRemove(gluexGeometry.getObjectByName("TOF_plane1_FTOT", true));
            scene.remove(gluexGeometry.getObjectByName("TOF_plane1_FTOT", true));

        }
    }

</script>

</body>
</html>
